Non-template functions that are members of class templates can be constrained in a similar way to what we have seen so far. This enables template classes to define member functions only for types that satisfy some requirements. In the following example, the equality operator is constrained:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct wrapper
{
	T value;
	
	bool operator==(std::string_view str)
	requires std::is_convertible_v<T, std::string_view>
	{
		return value == str;
	}
};
\end{lstlisting}

The wrapper class holds a value of a T type and defines the operator== member only for types that are convertible to std::string\_view. Let’s see how this can be used:

\begin{lstlisting}[style=styleCXX]
wrapper<int> a{ 42 };
wrapper<char const*> b{ "42" };

if(a == 42) {} // error
if(b == "42") {} // OK
\end{lstlisting}

We have two instantiations of the wrapper class here, one for int and one for char const*. The attempt to compare the a object with the literal 42 generates a compiler error, because the operator== is not defined for this type. However, comparing the b object with the string literal "42" is possible because the equality operator is defined for types that can be implicitly converted to std::string\_view, and char const* is such a type.

Constraining non-template members is useful because it’s a cleaner solution than forcing members to be templates and using SFINAE. To understand this better let’s consider the following implementation of the wrapper class:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct wrapper
{
	T value;
	
	wrapper(T const & v) :value(v) {}
};
\end{lstlisting}

This class template can be instantiated as follows:

\begin{lstlisting}[style=styleCXX]
wrapper<int> a = 42; //OK

wrapper<std::unique_ptr<int>> p =
	std::make_unique<int>(42); //error
\end{lstlisting}

The first line compiles successfully, but the second generates a compiler error. There are different messages issued by different compilers, but at the core of the error is the call to the implicitly deleted copy constructor of std::unique\_ptr.

What we want to do is restrict the copy construction of wrapper from objects of the T type so that it only works for T types that are copy-constructible. The approach available before C++20 was to transform the copy constructor into a template and employ SFINAE. This would look as follows:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct wrapper
{
	T value;
	template <typename U,
		typename = std::enable_if_t<
			std::is_copy_constructible_v<U> &&
			std::is_convertible_v<U, T>>>
	wrapper(U const& v) :value(v) {}
};
\end{lstlisting}

This time we also get an error when trying to initialize a wrapper<std::unique\_ ptr<int>> from an std::unique\_ptr<int> value but the errors are different. For instance, here are the error messages generated by Clang:

\begin{tcblisting}{commandshell={}}
prog.cc:19:35: error: no viable conversion from 'typename __
unique_if<int>::__unique_single' (aka 'unique_ptr<int>') to
   'wrapper<std::unique_ptr<int>>'
wrapper<std::unique_ptr<int>> p = std::make_
unique<int>(42); // error
                                        ^ ~~~~~~~~~~~~~~~~~~~~~~~~~
prog.cc:6:8: note: candidate constructor (the implicit copy
constructor) not viable: no known conversion from 'typename
__unique_if<int>::__unique_single' (aka 'unique_ptr<int>') to
'const wrapper<std::unique_ptr<int>> &' for 1st argument
struct wrapper
         ^
prog.cc:6:8: note: candidate constructor (the implicit move
constructor) not viable: no known conversion from 'typename
__unique_if<int>::__unique_single' (aka 'unique_ptr<int>') to
'wrapper<std::unique_ptr<int>> &&' for 1st argument
struct wrapper
         ^
prog.cc:13:9: note: candidate template ignored: requirement
'std::is_copy_constructible_v<std::unique_ptr<int,
std::default_delete<int>>>' was not satisfied [with U =
std::unique_ptr<int>]
        wrapper(U const& v) :value(v) {}
        ^
\end{tcblisting}

The most important message to help understand the cause of the problem is the last one. It says that the requirement that U substituted with std::unique\_ptr<int> does not satisfy the Boolean condition. In C++20, we can do a better job at implementing the same restriction on the T template argument. This time, we can use constraints and the copy constructor does not need to be a template anymore. The implementation in C++20 can look as follows:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct wrapper
{
	T value;
	wrapper(T const& v)
		requires std::is_copy_constructible_v<T>
		:value(v)
	{}
};
\end{lstlisting}

Not only there is less code that does not require complicated SFINAE machinery, but it is simpler and easier to understand. It also generates potentially better error messages. In the case of Clang, the last note listed earlier is replaced with the following:

\begin{tcblisting}{commandshell={}}
prog.cc:9:5: note: candidate constructor not viable:
constraints not satisfied
    wrapper(T const& v)
    ^

prog.cc:10:18: note: because 'std::is_copy_constructible_
v<std::unique_ptr<int> >' evaluated to false
        requires std::is_copy_constructible_v<T>
\end{tcblisting}

Before closing this section, it’s worth mentioning that not only non-template functions that are members of classes can be constrained but also free functions. The use cases for non-template functions are rare and can be achieved with alternative simple solutions such as constexpr if. Let’s look at an example, though:

\begin{lstlisting}[style=styleCXX]
void handle(int v)
{ /* do something */ }

void handle(long v)
	requires (sizeof(long) > sizeof(int))
{ /* do something else */ }
\end{lstlisting}

In this snippet, we have two overloads of the handle function. The first overload takes an int value and the second a long value. The body of these overloaded functions is not important but they should do different things, if and only if the size of long is different from the size of int. The standard specifies that the size of int is at least 16 bits, although on most platforms it is 32 bits. The size of long is at least 32 bits. However, there are platforms, such as LP64, where int is 32 bits and long is 64 bits. On these platforms, both overloads should be available. On all the other platforms, where the two types have the same size, only the first overload should be available. This can be defined in the form shown earlier, although the same can be achieved in C++17 with constexpr if as follows:

\begin{lstlisting}[style=styleCXX]
void handle(long v)
{
	if constexpr (sizeof(long) > sizeof(int))
	{
		/* do something else */
	}
	else
	{
		/* do something */
	}
}
\end{lstlisting}

In the next section, we’ll learn how to use constraints to define restrictions on template arguments of class templates.


