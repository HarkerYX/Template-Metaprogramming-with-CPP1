In Chapter 2, Template Fundamentals, we discussed generic lambdas, introduced in C++14, as well as lambda templates, introduced in C++20. A lambda that uses the auto specifier for at least one parameter is called a generic lambda. The function object generated by the compiler will have a templated call operator. Here is an example to refresh your memory:

\begin{lstlisting}[style=styleCXX]
auto lsum = [](auto a, auto b) {return a + b; };
\end{lstlisting}

The C++20 standard generalizes this feature for all functions. You can use the auto specifier in the function parameter list. This has the effect of transforming the function into a template function. Here is an example:

\begin{lstlisting}[style=styleCXX]
auto add(auto a, auto b)
{
	return a + b;
}
\end{lstlisting}

This is a function that takes two parameters and returns their sum (or to be more precise, the result of applying operator+ on the two values). Such a function using auto for function parameters is called an abbreviated function template. It is basically shorthand syntax for a function template. The equivalent template for the previous function is the following:

\begin{lstlisting}[style=styleCXX]
template<typename T, typename U>
auto add(T a, U b)
{
	return a + b;
}
\end{lstlisting}

We can call this function as we would call any template function, and the compiler will generate the proper instantiations by substituting the template arguments with the actual types. For instance, letâ€™s consider the following calls:

\begin{lstlisting}[style=styleCXX]
add(4, 2); // returns 6
add(4.0, 2); // returns 6.0
\end{lstlisting}

We can use the cppinsights.io website to check the compiler-generated code for the add abbreviated function template based on these two calls. The following specializations are generated:

\begin{lstlisting}[style=styleCXX]
template<>
int add<int, int>(int a, int b)
{
	return a + b;
}

template<>
double add<double, int>(double a, int b)
{
	return a + static_cast<double>(b);
}
\end{lstlisting}

Since an abbreviated function template is nothing but a regular function template with a simplified syntax, such a function can be explicitly specialized by the user. Here is an example:

\begin{lstlisting}[style=styleCXX]
template<>
auto add(char const* a, char const* b)
{
	return std::string(a) + std::string(b);
}
\end{lstlisting}

This is a full specialization for the char const* type. This specialization enables us to make calls such as add("4", "2"), although the result is a std::string value.

This category of abbreviated function templates is called unconstrained. There is no restriction on the template arguments. However, it is possible to provide constraints for their parameters with concepts. Abbreviated function templates that use concepts are called constrained. Next, you can see an example of an add function constrained for integral types:

\begin{lstlisting}[style=styleCXX]
auto add(std::integral auto a, std::integral auto b)
{
	return a + b;
}
\end{lstlisting}

If we consider again the same calls we saw earlier, the first would be successful, but the second would produce a compiler error because there is no overload that takes a double and an int value:

\begin{lstlisting}[style=styleCXX]
add(4, 2); // OK
add(4.2, 0); // error
\end{lstlisting}

Constrained auto can also be used for variadic abbreviated function templates.
An example is shown in the following snippet:

\begin{lstlisting}[style=styleCXX]
auto add(std::integral auto ... args)
{
	return (args + ...);
}
\end{lstlisting}

Last but not least, constrained auto can be used with generic lambdas too. If we would like the generic lambda shown at the beginning of this section to be used only with integral types, then we can constrain it as follows:

\begin{lstlisting}[style=styleCXX]
auto lsum = [](std::integral auto a, std::integral auto b)
{
	return a + b;
};
\end{lstlisting}

Last but not least, constrained auto can be used with generic lambdas too. If we would like the generic lambda shown at the beginning of this section to be used only with integral types, then we can constrain it as follows:

\begin{lstlisting}[style=styleCXX]
auto lsum = [](std::integral auto a, std::integral auto b)
{
	return a + b;
};
\end{lstlisting}

With the closing of this section, we have seen all the language features related to concepts and constraints in C++20. What is left to discuss is the set of concepts provided by the standard library, of which we have seen a couple already. We will do this next.






























