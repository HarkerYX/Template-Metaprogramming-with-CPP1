C++11中添加到该语言的最重要的特性之一是移动语义，通过避免不必要的复制来帮助提高性能。移动语义由C++11的另一个特性支持，称为右值引用。在讨论这些之前，值得一提的是，在C++中有两种值:

\begin{itemize}
\item
左值是指向内存位置的值，因此，可以用\&操作符获取它们的地址。左值可以出现在赋值表达式的左边和右边。

\item
右值是非左值的值，它们的定义是互斥的。右值不指向内存位置，并且不能使用\&操作符获取它们的地址。右值是字面量和临时对象，只能出现在赋值表达式的右侧。

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={Note}]
C++11中，还有一些其他的值类别，glvalue, prvalue和xvalue。在这里讨论它们会让我们的精力过于分散，可以在\url{https://en.cppreference.com/w/cpp/ language/value_category}上阅读更多关于它们的信息。
\end{tcolorbox}

\end{itemize}

引用是已经存在的对象或函数的别名。就像我们有两种值一样，C++11中有两种引用:

\begin{itemize}
\item
用\&表示的左值引用，例如\&x，是对左值的引用。

\item
用\&\&表示的右值引用，例如在\&\&x中，是对右值的引用。
\end{itemize}

来看一些例子，可以更好地理解这些概念:

\begin{lstlisting}[style=styleCXX]
struct foo
{
	int data;
};

void f(foo& v)
{ std::cout << "f(foo&)\n"; }

void g(foo& v)
{ std::cout << "g(foo&)\n"; }

void g(foo&& v)
{ std::cout << "g(foo&&)\n"; }

void h(foo&& v)
{ std::cout << "h(foo&&)\n"; }

foo x = { 42 }; // x is lvalue
foo& rx = x; // rx is lvalue
\end{lstlisting}

这里有三个函数:f，它接受一个左值引用(即int\&);g，它有两个重载，一个用于左值引用，另一个用于右值引用(即int\&\&);h，取一个右值引用。还有两个变量，x和rx。x是一个左值，类型为foo，可以用\&x看到它的地址。左值也是rx，它是一个左值引用，类型是foo\&。现在，来看看如何调用f、g和h函数:

\begin{lstlisting}[style=styleCXX]
f(x); // f(foo&)
f(rx); // f(foo&)
f(foo{42}); // error: a non-const reference
            // may only be bound to an lvalue
\end{lstlisting}

因为x和rx都是左值，所以将它们传递给f没问题，因为这个函数接受一个左值引用。然而，foo\{42\}是一个临时对象，并且因为它不存在于调用f的上下文之外，所以它是一个右值，将它传递给f将导致编译器错误，因为函数的形参是foo\&类型的，非常量引用只能绑定到左值。若函数f的签名更改为f(int const \&v)，就没问题了。接下来，讨论g函数:

\begin{lstlisting}[style=styleCXX]
g(x); // g(foo&)
g(rx); // g(foo&)
g(foo{ 42 }); // g(foo&&)
\end{lstlisting}

前面的代码段中，使用x或rx调用g将解析为第一个重载，该重载接受左值引用。但使用foo\{42\}(foo\{42\}是一个临时对象，因此是一个右值)将解析为第二个重载，将接受一个右值引用。看当我们想对h函数进行相同的调用时会发生什么:

\begin{lstlisting}[style=styleCXX]
h(x); // error, cannot bind an lvalue to an rvalue ref
h(rx); // error
h(foo{ 42 }); // h(foo&&)
h(std::move(x)); // h(foo&&)
\end{lstlisting}

该函数可以接受一个右值引用，但将x或rx传递给它会导致编译器错误，因为左值不能绑定到右值引用。表达式foo\{42\}是一个右值，可以作为参数传递。若把其语义从左值改为右值(可在std::move的帮助下完成)，也可以把左值x传递给函数h。std::move并不真正移动任何东西，只是做了一种从左值到右值的转换而已。

However, it is important to understand that passing rvalues to a function has two purposes: either the object is temporary and does not exist outside the call and the function can do anything with it, or the function is supposed to take ownership of the object that is received. This is the purpose of the move constructor and the move assignment operator and it’s rare that you will see other functions taking rvalue references. In our last example, within the function h, the parameter v is an lvalue but it is bound to an rvalue. The variable x existed outside the call to h but passing it to std::move transformed it into an rvalue. It still exists as an lvalue after the call to h returns but you should assume the function h did something with it and its state can be anything.

One purpose of rvalue references is, therefore, to enable move semantics. But it has yet another one and that is to enable perfect forwarding. To understand this, let’s consider the following modified scenario of the previous functions g and h:

\begin{lstlisting}[style=styleCXX]
void g(foo& v) { std::cout << "g(foo&)\n"; }
void g(foo&& v) { std::cout << "g(foo&&)\n"; }

void h(foo& v) { g(v); }
void h(foo&& v) { g(v); }
\end{lstlisting}

In this snippet, the implementation of g is identical to the one seen earlier. However, h also has two overloads, one that takes an lvalue reference and calls g and another one that takes an rvalue reference and also calls g. In other words, the function h is just forwarding the argument to g. Now, let’s consider the following calls:

\begin{lstlisting}[style=styleCXX]
foo x{ 42 };
h(x); // g(foo&)
h(foo{ 42 }); // g(foo&)
\end{lstlisting}

From this, you would expect that the call h(x) will result in a call to the g overload taking an lvalue reference and the call to h(foo\{42\}) will result in a call to the g overload taking an rvalue reference. However, in fact, both of them will call the first overload of g, therefore printing g(foo\&) to the console. The explanation is actually simple once you understand how references work: in the context h(foo\&\& v), the parameter v is actually an lvalue (it has a name and you can take its address) so calling g with it invokes the overload that takes an lvalue reference. To make it work as intended, we need to change the implementation of the h functions as follows:

\begin{lstlisting}[style=styleCXX]
void h(foo& v) { g(std::forward<foo&>(v)); }
void h(foo&& v) { g(std::forward<foo&&>(v)); }
\end{lstlisting}

The std::forward is a function that enables the correct forwarding of values. What the function does is as follows:

\begin{itemize}
\item
If the argument is an lvalue reference, then the function behaves just as a call to std::move (changing the semantics from an lvalue to an rvalue).

\item
If the argument is an rvalue reference, then it does nothing.
\end{itemize}

Everything that we discussed so far is unrelated to templates, which are the subject of this book. However, function templates can also be used to take lvalue and rvalue references and it’s important to understand first how these work in non-templates scenarios. This is because, in templates, rvalue references work slightly differently, and sometimes they are rvalue references, but other times they are actually lvalue references.

References that exhibit this behavior are called forwarding references. However, they are often referred to as universal references. This was a term coined by Scott Meyers shortly after C++11 when there was no term in the standard for this type of reference. In order to address this shortcoming, and because it didn’t feel the term universal references properly described their semantics, the C++ standard committee called these forwarding references in C++14. Yet, both terms are equally present in literature. For the sake of being true to the standard terminology, we’ll call them forwarding references in this book.

To begin the discussion on forwarding references, let’s consider the following overloaded function templates and class templates:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void f(T&& arg) // forwarding reference
{ std::cout << "f(T&&)\n"; }

template <typename T>
void f(T const&& arg) // rvalue reference
{ std::cout << "f(T const&&)\n"; }

template <typename T>
void f(std::vector<T>&& arg) // rvalue reference
{ std::cout << "f(vector<T>&&)\n"; }

template <typename T>
struct S
{
	void f(T&& arg) // rvalue reference
	{ std::cout << "S.f(T&&)\n"; }
};
\end{lstlisting}

We can make calls to these functions as follows:

\begin{lstlisting}[style=styleCXX]
int x = 42;
f(x); // [1] f(T&&)
f(42); // [2] f(T&&)

int const cx = 100;
f(cx); // [3] f(T&&)
f(std::move(cx)); // [4] f(T const&&)

std::vector<int> v{ 42 };
f(v); // [5] f(T&&)
f(std::vector<int>{42});// [6] f(vector<T>&&)

S<int> s;
s.f(x); // [7] error
s.f(42); // [8] S.f(T&&)
\end{lstlisting}

From this snippet, we can notice that:

\begin{itemize}
\item
Calling f with an lvalue or rvalue at [1] and [2] resolves to the first overload, f(T\&\&).

\item
Calling f with a constant lvalue at [3] also resolves to the first overload, but calling f with a constant rvalue at [4] resolves to the second overload, f(T const\&\&), because it’s a better match.

\item
Calling f with an lvalue std::vector object at [5] resolves to the first overload, but calling f with an rvalue std::vector object at [6] resolves to the third overload, f(vector<T>\&\&), because it’s a better match.

\item
Calling S::f with an lvalue at [7] is an error because lvalues cannot be bound to rvalue references, but calling it with an rvalue at [8] is correct.
\end{itemize}

All the f function overloads in this example take an rvalue reference. However, the \&\& in the first overload does not necessarily mean an rvalue reference. It means an rvalue reference if an rvalue was passed or an lvalue reference if an lvalue was passed. Such a reference is called a forwarding reference. However, forwarding references are only present in the context of an rvalue reference to a template parameter. It has to have the form T\&\& and nothing else. T const\&\& or std::vector<T>\&\& are not forwarding references, but normal rvalue references. Similarly, the T\&\& in the f function member of the class template S is also an rvalue reference because f is not a template but a non-template member function of a class template, so this rule for forwarding references does not apply.

Forwarding references are a special case of function template argument deduction, a topic that we previously discussed in this chapter. Their purpose is to enable perfect forwarding with templates and they are made possible by a new C++11 feature called reference collapsing. Let’s look at this first, before showing how they solve the perfect forwarding problem.

Prior to C++11, it was not possible to take a reference to a reference. However, that is now possible in C++11 for typedefs and templates. Here is an example:

\begin{lstlisting}[style=styleCXX]
using lrefint = int&;
using rrefint = int&&;
int x = 42;
lrefint& r1 = x; // type of r1 is int&
lrefint&& r2 = x; // type of r2 is int&
rrefint& r3 = x; // type of r3 is int&
rrefint&& r4 = 1; // type of r4 is int&&
\end{lstlisting}

The rule is pretty simple: an rvalue reference to an rvalue reference collapses to an rvalue reference; all other combinations collapse to an lvalue reference. This can be put in a tabular form as follows:

\begin{table}[H]
\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Type} & \textbf{Type of reference} & \textbf{Type of variable} \\ \hline
		T\&           & T\&                        & T\&                       \\ \hline
		T\&           & T\&\&                      & T\&                       \\ \hline
		T\&\&         & T\&                        & T\&                       \\ \hline
		T\&\&         & T\&\&                      & T\&\&                     \\ \hline
	\end{tabular}
\end{table}

\begin{center}
Table 4.2
\end{center}

Any other combinations, shown in the following table, do not involve reference collapsing rules. These only apply when both types are references:

\begin{table}[H]
\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Type} & \textbf{Type of reference} & \textbf{Type of variable} \\ \hline
		T             & T                          & T                         \\ \hline
		T             & T\&                        & T\&                       \\ \hline
		T             & T\&\&                      & T\&\&                     \\ \hline
		T\&           & T                          & T\&                       \\ \hline
		T\&\&         & T                          & T\&\&                     \\ \hline
	\end{tabular}
\end{table}

\begin{center}
	Table 4.3
\end{center}

Forwarding references work not only for templates but also with auto deduction rules. When auto\&\& is found, it means a forwarding reference. The same does not apply for anything else, such as cv-qualified forms like auto const\&\&. Here are some examples:

\begin{lstlisting}[style=styleCXX]
int x = 42;
auto&& rx = x; // [1] int&
auto&& rc = 42; // [2] int&&
auto const&& rcx = x; // [3] error

std::vector<int> v{ 42 };
auto&& rv = v[0]; // [4] int&
\end{lstlisting}

In the first two examples, rx and rc are both forwarding references and are bound to an lvalue and an rvalue respectively. However, rcx is an rvalue reference because auto const\&\& does not denote a forwarding reference. Therefore, trying to bind it to an lvalue is an error. Similarly, rv is a forwarding reference and is bound to an lvalue.

As previously mentioned, the purpose of forwarding references is to enable perfect forwarding. We have seen the concept of perfect forwarding earlier but in a non-template context. It works, however, in a similar manner with templates. To demonstrate this, let’s redefine the function h as a template function. It would look as follows:

\begin{lstlisting}[style=styleCXX]
void g(foo& v) { std::cout << "g(foo&)\n"; }
void g(foo&& v) { std::cout << "g(foo&&)\n"; }

template <typename T> void h(T& v) { g(v); }
template <typename T> void h(T&& v) { g(v); }

foo x{ 42 };
h(x); // g(foo&)
h(foo{ 42 }); // g(foo&)
\end{lstlisting}

The implementation of the g overloads is the same, but the h overloads are now function templates. However, calling h with an lvalue and an rvalue actually resolves to the same call to g, the first overload taking an lvalue. This is because in the context of the function h, v is an lvalue so passing it to g will call the overload taking an lvalue.

The solution to this problem is the same as what we already saw before discussing templates. However, there is a difference: we no longer need two overloads, but a single one taking a forwarding reference:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void h(T&& v)
{
	g(std::forward<T>(v));
}
\end{lstlisting}

This implementation is using std::forward to pass lvalues as lvalues and rvalues as rvalues. It works similarly for variadic function templates. The following is a conceptual implementation of the std::make\_unique function that creates a std::unique\_ptr object:

\begin{lstlisting}[style=styleCXX]
	void g(foo& v) { std::cout << "g(foo&)\n"; }
	void g(foo&& v) { std::cout << "g(foo&&)\n"; }
	
	template <typename T> void h(T& v) { g(v); }
	template <typename T> void h(T&& v) { g(v); }
	
	foo x{ 42 };
	h(x); // g(foo&)
	h(foo{ 42 }); // g(foo&)
\end{lstlisting}

To summarize this section, remember that forwarding references (also known as universal references) are basically a special deduction rule for function template arguments. They work based on the rules of reference collapsing and their purpose is to enable perfect forwarding. That is passing forward to another function a reference by preserving its valueness semantics: rvalues should be passed as rvalues and lvalues as lvalues.

The next topic that we will address in this chapter is the decltype specifier.













