Earlier in this book, we have briefly talked about the fact that the compiler can sometimes deduce the template arguments from the context of the function call, allowing you to avoid explicitly specifying them. The rules for template argument deduction are more complex and we will explore this topic in this section.

Letâ€™s start the discussion by looking at a simple example:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process(T arg)
{
	std::cout << "process " << arg << '\n';
}

int main()
{
	process(42); // [1] T is int
	process<int>(42); // [2] T is int, redundant
	process<short>(42); // [3] T is short
}
\end{lstlisting}

In this snippet, process is a function template with a single type template parameter. The calls process(42) and process<int>(42) are identical because, in the first case, the compiler is able to deduce the type of the type template parameter T as int from the value of the argument passed to the function.

When the compiler tries to deduce the template arguments, it performs the matching of the types of the template parameters with the types of the arguments used to invoke the function. There are some rules that govern this matching. The compiler can match the following:

\begin{itemize}
\item
Types (both cv-qualified and non-qualified) of the form T, T const, T volatile:

\begin{lstlisting}[style=styleCXX]
struct account_t
{
	int number;
};

template <typename T>
void process01(T) { std::cout << "T\n"; }

template <typename T>
void process02(T const) { std::cout << "T const\n"; }

template <typename T>
void process03(T volatile) { std::cout << "T volatile\n";
}

int main()
{
	account_t ac{ 42 };
	process01(ac); // T
	process02(ac); // T const
	process03(ac); // T volatile
}
\end{lstlisting}

\item
Pointers (T*), l-value references (T\&), and r-value references (T\&\&):

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process04(T*) { std::cout << "T*\n"; }

template <typename T>
void process04(T&) { std::cout << "T&\n"; }

template <typename T>
void process05(T&&) { std::cout << "T&&\n"; }

int main()
{
	account_t ac{ 42 };
	process04(&ac); // T*
	process04(ac); // T&
	process05(ac); // T&&
}
\end{lstlisting}

\item
Arrays such as T[5], or C[5][n], where C is a class type and n is a non-type template argument:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process06(T[5]) { std::cout << "T[5]\n"; }

template <size_t n>
void process07(account_t[5][n])
{ std::cout << "C[5][n]\n"; }

int main()
{
	account_t arr1[5] {};
	process06(arr1); // T[5]
	
	account_t ac{ 42 };
	process06(&ac); // T[5]
	
	account_t arr2[5][3];
	process07(arr2); // C[5][n]
}
\end{lstlisting}

\item
Pointers to functions, with the form T(*)(), C(*)(T), and T(*)(U), where C is a class type and T and U are type template parameters:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void process08(T(*)()) { std::cout << "T (*)()\n"; }

template<typename T>
void process08(account_t(*)(T))
{ std::cout << "C (*) (T)\n"; }

template<typename T, typename U>
void process08(T(*)(U)) { std::cout << "T (*)(U)\n"; }

int main()
{
	account_t (*pf1)() = nullptr;
	account_t (*pf2)(int) = nullptr;
	double (*pf3)(int) = nullptr;
	
	process08(pf1); // T (*)()
	process08(pf2); // C (*)(T)
	process08(pf3); // T (*)(U)
}
\end{lstlisting}

\item
Pointers to member functions with one of the following forms, T (C::*)(), T (C::*)(U), T (U::*)(), T (U::*)(V), C (T::*)(), C (T::*)(U), and D (C::*)(T), where C and D are class types and T, U, and V are type template parameters:

\begin{lstlisting}[style=styleCXX]
struct account_t
{
	int number;
	int get_number() { return number; }
	int from_string(std::string text) {
		return std::atoi(text.c_str()); }
};

struct transaction_t
{
	double amount;
};

struct balance_report_t {};
struct balance_t
{
	account_t account;
	double amount;
	
	account_t get_account() { return account; }
	int get_account_number() { return account.number; }
	bool can_withdraw(double const value)
		{return amount >= value; };
	transaction_t withdraw(double const value) {
		amount -= value; return transaction_t{ -value }; }
	balance_report_t make_report(int const type)
	{return {}; }
};

template<typename T>
void process09(T(account_t::*)())
{ std::cout << "T (C::*)()\n"; }

template<typename T, typename U>
void process09(T(account_t::*)(U))
{ std::cout << "T (C::*)(U)\n"; }

template<typename T, typename U>
void process09(T(U::*)())
{ std::cout << "T (U::*)()\n"; }

template<typename T, typename U, typename V>
void process09(T(U::*)(V))
{ std::cout << "T (U::*)(V)\n"; }

template<typename T>
void process09(account_t(T::*)())
{ std::cout << "C (T::*)()\n"; }

template<typename T, typename U>
void process09(transaction_t(T::*)(U))
{ std::cout << "C (T::*)(U)\n"; }

template<typename T>
void process09(balance_report_t(balance_t::*)(T))
{ std::cout << "D (C::*)(T)\n"; }

int main()
{
	int (account_t::* pfm1)() = &account_t::get_number;
	int (account_t::* pfm2)(std::string) =
		&account_t::from_string;
	int (balance_t::* pfm3)() =
		&balance_t::get_account_number;
	bool (balance_t::* pfm4)(double) =
		&balance_t::can_withdraw;
	account_t (balance_t::* pfm5)() =
		&balance_t::get_account;
	transaction_t(balance_t::* pfm6)(double) =
		&balance_t::withdraw;
	balance_report_t(balance_t::* pfm7)(int) =
		&balance_t::make_report;
		
	process09(pfm1); // T (C::*)()
	process09(pfm2); // T (C::*)(U)
	process09(pfm3); // T (U::*)()
	process09(pfm4); // T (U::*)(V)
	process09(pfm5); // C (T::*)()
	process09(pfm6); // C (T::*)(U)
	process09(pfm7); // D (C::*)(T)
}
\end{lstlisting}

\item
Pointers to data members such as T C::*, C T::*, and T U::*, where C is a class type and T and U are type template parameters:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void process10(T account_t::*)
{ std::cout << "T C::*\n"; }

template<typename T>
void process10(account_t T::*)
{ std::cout << "C T::*\n"; }

template<typename T, typename U>
void process10(T U::*) { std::cout << "T U::*\n"; }

int main()
{
	process10(&account_t::number); // T C::*
	process10(&balance_t::account); // C T::*
	process10(&balance_t::amount); // T U::*
}
\end{lstlisting}

\item
A template with an argument list that contains at least one type template parameter; the general form is C<T>, where C is a class type and T is a type template parameter:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct wrapper
{
	T data;
};

template<typename T>
void process11(wrapper<T>) { std::cout << "C<T>\n"; }

int main()
{
	wrapper<double> wd{ 42.0 };
	process11(wd); // C<T>
}
\end{lstlisting}

\item
A template with an argument list that contains at least one non-type template argument; the general form is C<i>, where C is a class type and i a non-type template argument:

\begin{lstlisting}[style=styleCXX]
template <size_t i>
struct int_array
{
	int data[i];
};

template<size_t i>
void process12(int_array<i>) { std::cout << "C<i>\n"; }

int main()
{
	int_array<5> ia{};
	process12(ia); // C<i>
}
\end{lstlisting}

\item
A template template argument with an argument list that contains at least one type template parameter; the general form is TT<T>, where TT is a template template parameter and T is a type template:

\begin{lstlisting}[style=styleCXX]
template<template<typename> class TT, typename T>
void process13(TT<T>) { std::cout << "TT<T>\n"; }

int main()
{
	wrapper<double> wd{ 42.0 };
	process13(wd); // TT<U>
}
\end{lstlisting}

\item
A template template argument with an argument list that contains at least one non-type template argument; the general form is TT<i>, where TT is a template template parameter and i is a non-type template argument:

\begin{lstlisting}[style=styleCXX]
template<template<size_t> typename TT, size_t i>
void process14(TT<i>) { std::cout << "TT<i>\n"; }
int main()
{
	int_array<5> ia{};
	process14(ia); // TT<i>
}
\end{lstlisting}

\item
A template template argument with an argument list that has no template arguments dependent on a template parameter; this has the form TT<C>, where TT is the template template parameter and C is a class type:

\begin{lstlisting}[style=styleCXX]
template<template<typename> typename TT>
void process15(TT<account_t>) { std::cout << "TT<C>\n"; }

int main()
{
	wrapper<account_t> wa{ {42} };
	process15(wa); // TT<C>
}
\end{lstlisting}
\end{itemize}

Although the compiler is able to deduce many types of template parameters, as previously seen, there are also limitations to what it can do. These are exemplified in the following list:

\begin{itemize}
\item
The compiler cannot deduce the type of a type template argument, from the type of a non-type template argument. In the following example, process is a function template with two template parameters: a type template called T, and a non-type template i of the type T. Calling the function with an array of five doubles does not allow the compiler to determine the type of T, even though this is the type of the value specifying the size of the array:

\begin{lstlisting}[style=styleCXX]
template <typename T, T i>
void process(double arr[i])
{
	using index_type = T;
	std::cout << "processing " << i
	          << " doubles" << '\n';
	          
	std::cout << "index type is "
              << typeid(T).name() << '\n';
}

int main()
{
	double arr[5]{};
	process(arr); // error
	process<int, 5>(arr); // OK
}
\end{lstlisting}

\item
The compiler is not able to determine the type of a template argument from the type of a default value. This is exemplified ahead in the code with the function template process, which has a single type template parameter, but two function parameters, both of type T and both with default values.

The process() call (without any arguments) fails because the compiler cannot deduce the type of the type template parameter T from the default values of the function parameters. The process<int>() call is OK because the template argument is explicitly provided. The process(6) call is also OK, because the type of the first function parameter can be deduced from the supplied argument, and, therefore, the type template argument can also be deduced:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process(T a = 0, T b = 42)
{
	std::cout << a << "," << b << '\n';
}

int main()
{
	process(); // [1] error
	process<int>(); // [2] OK
	process(10); // [3] OK
}
\end{lstlisting}

\item
Although the compiler can deduce function template arguments from pointer to functions or pointer to member functions, as we have seen earlier, there are a couple of restrictions to this capability: it cannot deduce arguments from pointers to function templates, nor from a pointer to a function that has an overloaded set with more than one overloaded function matching the required type.

In the code ahead, the function template invoke takes a pointer to a function that has two arguments, the first of the type template parameter T, and the second an int, and returns void. This function template cannot be passed a pointer to alpha (see [1]) because this is a function template, nor to beta (see [2]), because this has more than one overload that can match the type T. However, it is possible to call it with a pointer to gamma (see [3]), and it will correctly deduce the type of the second overload:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void invoke(void(*pfun)(T, int))
{
	pfun(T{}, 42);
}

template <typename T>
void alpha(T, int)
{ std::cout << "alpha(T,int)" << '\n'; }

void beta(int, int)
{ std::cout << "beta(int,int)" << '\n'; }

void beta(short, int)
{ std::cout << "beta(short,int)" << '\n'; }

void gamma(short, int, long long)
{ std::cout << "gamma(short,int,long long)" << '\n'; }

void gamma(double, int)
{ std::cout << "gamma(double,int)" << '\n'; }

int main()
{
	invoke(&alpha); // [1] error
	invoke(&beta); // [2] error
	invoke(&gamma); // [3] OK
}
\end{lstlisting}

\item
Another limitation of the compiler is the argument deduction of the primary dimension of an array. The reason is this is not part of function parameter types. The exceptions to this limitation are the cases when the dimension refers to a reference or pointer type. The following code snippet demonstrates these restrictions:

\begin{itemize}
\item
The call to process1() at [1] generates an error because the compiler is not able to deduce the value of the non-type template argument Size, since this refers to the primary dimension of an array.

\item
The call to process2() at the point marked with [2] is correct because the non-type template parameter Size refers to the second dimension of an array.

\item 
On the other hand, the calls to process3() (at [3]) and process4() (at [4]) are both successful, since the function argument is either a reference or a pointer to a single-dimensional array:

\begin{lstlisting}[style=styleCXX]
template <size_t Size>
void process1(int a[Size])
{ std::cout << "process(int[Size])" << '\n'; };

template <size_t Size>
void process2(int a[5][Size])
{ std::cout << "process(int[5][Size])" << '\n'; };

template <size_t Size>
void process3(int(&a)[Size])
{ std::cout << "process(int[Size]&)" << '\n'; };

template <size_t Size>
void process4(int(*a)[Size])
{ std::cout << "process(int[Size]*)" << '\n'; };

int main()
{
	int arr1[10];
	int arr2[5][10];
	process1(arr1); // [1] error
	process2(arr2); // [2] OK
	process3(arr1); // [3] OK
	process4(&arr1); // [4] OK
}
\end{lstlisting}

\end{itemize}

\item
If a non-type template argument is used in an expression in the function template parameter list, then the compiler cannot deduce its value.

In the following snippet, ncube is a class template with a non-type template parameter N representing a number of dimensions. The function template process also has a non-type template parameter N, but this is used in an expression in the template parameter list of the type of its single parameter. As a result, the compiler cannot deduce the value of N from the type of the function argument (as seen at [1]) and this must be specified explicitly (as seen at [2]):

\begin{lstlisting}[style=styleCXX]
template <size_t N>
struct ncube
{
	static constexpr size_t dimensions = N;
};

template <size_t N>
void process(ncube<N - 1> cube)
{
	std::cout << cube.dimensions << '\n';
}

int main()
{
	ncube<5> cube;
	process(cube); // [1] error
	process<6>(cube); // [2] OK
}
\end{lstlisting}
\end{itemize}

All the rules for template argument deduction discussed in this section also apply to variadic function templates. However, everything that was discussed was in the context of function templates. Template argument deduction works for class templates too and we will explore this topic in the next section.













































