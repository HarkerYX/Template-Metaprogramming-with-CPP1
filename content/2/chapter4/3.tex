Earlier in this book, we have briefly talked about the fact that the compiler can sometimes deduce the template arguments from the context of the function call, allowing you to avoid explicitly specifying them. The rules for template argument deduction are more complex and we will explore this topic in this section.

Letâ€™s start the discussion by looking at a simple example:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process(T arg)
{
	std::cout << "process " << arg << '\n';
}

int main()
{
	process(42); // [1] T is int
	process<int>(42); // [2] T is int, redundant
	process<short>(42); // [3] T is short
}
\end{lstlisting}

In this snippet, process is a function template with a single type template parameter. The calls process(42) and process<int>(42) are identical because, in the first case, the compiler is able to deduce the type of the type template parameter T as int from the value of the argument passed to the function.

When the compiler tries to deduce the template arguments, it performs the matching of the types of the template parameters with the types of the arguments used to invoke the function. There are some rules that govern this matching. The compiler can match the following:

\begin{itemize}
\item
Types (both cv-qualified and non-qualified) of the form T, T const, T volatile:

\begin{lstlisting}[style=styleCXX]
struct account_t
{
	int number;
};

template <typename T>
void process01(T) { std::cout << "T\n"; }

template <typename T>
void process02(T const) { std::cout << "T const\n"; }

template <typename T>
void process03(T volatile) { std::cout << "T volatile\n";
}

int main()
{
	account_t ac{ 42 };
	process01(ac); // T
	process02(ac); // T const
	process03(ac); // T volatile
}
\end{lstlisting}

\item
Pointers (T*), l-value references (T\&), and r-value references (T\&\&):

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process04(T*) { std::cout << "T*\n"; }

template <typename T>
void process04(T&) { std::cout << "T&\n"; }

template <typename T>
void process05(T&&) { std::cout << "T&&\n"; }

int main()
{
	account_t ac{ 42 };
	process04(&ac); // T*
	process04(ac); // T&
	process05(ac); // T&&
}
\end{lstlisting}

\item
Arrays such as T[5], or C[5][n], where C is a class type and n is a non-type template argument:

\begin{lstlisting}[style=styleCXX]
template <typename T>
void process06(T[5]) { std::cout << "T[5]\n"; }

template <size_t n>
void process07(account_t[5][n])
{ std::cout << "C[5][n]\n"; }

int main()
{
	account_t arr1[5] {};
	process06(arr1); // T[5]
	
	account_t ac{ 42 };
	process06(&ac); // T[5]
	
	account_t arr2[5][3];
	process07(arr2); // C[5][n]
}
\end{lstlisting}

\item
Pointers to functions, with the form T(*)(), C(*)(T), and T(*)(U), where C is a class type and T and U are type template parameters:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void process08(T(*)()) { std::cout << "T (*)()\n"; }

template<typename T>
void process08(account_t(*)(T))
{ std::cout << "C (*) (T)\n"; }

template<typename T, typename U>
void process08(T(*)(U)) { std::cout << "T (*)(U)\n"; }

int main()
{
	account_t (*pf1)() = nullptr;
	account_t (*pf2)(int) = nullptr;
	double (*pf3)(int) = nullptr;
	
	process08(pf1); // T (*)()
	process08(pf2); // C (*)(T)
	process08(pf3); // T (*)(U)
}
\end{lstlisting}

\item
Pointers to member functions with one of the following forms, T (C::*)(), T (C::*)(U), T (U::*)(), T (U::*)(V), C (T::*)(), C (T::*)(U), and D (C::*)(T), where C and D are class types and T, U, and V are type template parameters:

\begin{lstlisting}[style=styleCXX]
struct account_t
{
	int number;
	int get_number() { return number; }
	int from_string(std::string text) {
		return std::atoi(text.c_str()); }
};

struct transaction_t
{
	double amount;
};

struct balance_report_t {};
struct balance_t
{
	account_t account;
	double amount;
	
	account_t get_account() { return account; }
	int get_account_number() { return account.number; }
	bool can_withdraw(double const value)
		{return amount >= value; };
	transaction_t withdraw(double const value) {
		amount -= value; return transaction_t{ -value }; }
	balance_report_t make_report(int const type)
	{return {}; }
};

template<typename T>
void process09(T(account_t::*)())
{ std::cout << "T (C::*)()\n"; }

template<typename T, typename U>
void process09(T(account_t::*)(U))
{ std::cout << "T (C::*)(U)\n"; }

template<typename T, typename U>
void process09(T(U::*)())
{ std::cout << "T (U::*)()\n"; }

template<typename T, typename U, typename V>
void process09(T(U::*)(V))
{ std::cout << "T (U::*)(V)\n"; }

template<typename T>
void process09(account_t(T::*)())
{ std::cout << "C (T::*)()\n"; }

template<typename T, typename U>
void process09(transaction_t(T::*)(U))
{ std::cout << "C (T::*)(U)\n"; }

template<typename T>
void process09(balance_report_t(balance_t::*)(T))
{ std::cout << "D (C::*)(T)\n"; }

int main()
{
	int (account_t::* pfm1)() = &account_t::get_number;
	int (account_t::* pfm2)(std::string) =
		&account_t::from_string;
	int (balance_t::* pfm3)() =
		&balance_t::get_account_number;
	bool (balance_t::* pfm4)(double) =
		&balance_t::can_withdraw;
	account_t (balance_t::* pfm5)() =
		&balance_t::get_account;
	transaction_t(balance_t::* pfm6)(double) =
		&balance_t::withdraw;
	balance_report_t(balance_t::* pfm7)(int) =
		&balance_t::make_report;
		
	process09(pfm1); // T (C::*)()
	process09(pfm2); // T (C::*)(U)
	process09(pfm3); // T (U::*)()
	process09(pfm4); // T (U::*)(V)
	process09(pfm5); // C (T::*)()
	process09(pfm6); // C (T::*)(U)
	process09(pfm7); // D (C::*)(T)
}
\end{lstlisting}

\item
Pointers to data members such as T C::*, C T::*, and T U::*, where C is a class type and T and U are type template parameters:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void process10(T account_t::*)
{ std::cout << "T C::*\n"; }

template<typename T>
void process10(account_t T::*)
{ std::cout << "C T::*\n"; }

template<typename T, typename U>
void process10(T U::*) { std::cout << "T U::*\n"; }

int main()
{
	process10(&account_t::number); // T C::*
	process10(&balance_t::account); // C T::*
	process10(&balance_t::amount); // T U::*
}
\end{lstlisting}

\item
A template with an argument list that contains at least one type template parameter; the general form is C<T>, where C is a class type and T is a type template parameter:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct wrapper
{
	T data;
};

template<typename T>
void process11(wrapper<T>) { std::cout << "C<T>\n"; }

int main()
{
	wrapper<double> wd{ 42.0 };
	process11(wd); // C<T>
}
\end{lstlisting}

\item
A template with an argument list that contains at least one non-type template argument; the general form is C<i>, where C is a class type and i a non-type template argument:

\begin{lstlisting}[style=styleCXX]
template <size_t i>
struct int_array
{
	int data[i];
};

template<size_t i>
void process12(int_array<i>) { std::cout << "C<i>\n"; }

int main()
{
	int_array<5> ia{};
	process12(ia); // C<i>
}
\end{lstlisting}

\item
A template template argument with an argument list that contains at least one type template parameter; the general form is TT<T>, where TT is a template template parameter and T is a type template:

\begin{lstlisting}[style=styleCXX]
template<template<typename> class TT, typename T>
void process13(TT<T>) { std::cout << "TT<T>\n"; }

int main()
{
	wrapper<double> wd{ 42.0 };
	process13(wd); // TT<U>
}
\end{lstlisting}

\item
A template template argument with an argument list that contains at least one non-type template argument; the general form is TT<i>, where TT is a template template parameter and i is a non-type template argument:

\begin{lstlisting}[style=styleCXX]
template<template<size_t> typename TT, size_t i>
void process14(TT<i>) { std::cout << "TT<i>\n"; }
int main()
{
	int_array<5> ia{};
	process14(ia); // TT<i>
}
\end{lstlisting}

\item
A template template argument with an argument list that has no template arguments dependent on a template parameter; this has the form TT<C>, where TT is the template template parameter and C is a class type:

\begin{lstlisting}[style=styleCXX]
template<template<typename> typename TT>
void process15(TT<account_t>) { std::cout << "TT<C>\n"; }

int main()
{
	wrapper<account_t> wa{ {42} };
	process15(wa); // TT<C>
}
\end{lstlisting}
\end{itemize}

Although the compiler is able to deduce many types of template parameters, as previously seen, there are also limitations to what it can do. These are exemplified in the following list:

















































