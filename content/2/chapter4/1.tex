
“名称绑定”指的是查找模板中使用的每个名称的声明的过程。模板中使用两种名称:依赖名称和非依赖名称。前者是依赖模板参数的类型或值的名称，可以是类型参数、非类型形参或模板参数。不依赖于模板参数的名称称为非依赖名称。依赖名称和非依赖名称的查找方式不同:

\begin{itemize}
\item
依赖名称，在模板实例化时执行。

\item
非依赖名称，则在模板定义时执行。
\end{itemize}

首先，来看看非依赖名称，位于模板定义的前面。为了了解这是如何工作的，看一下下面的例子:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct parser; // [1] template declaration
void handle(double value) // [2] handle(double) definition
{
	std::cout << "processing a double: " << value << '\n';
}

template <typename T>
struct parser // [3] template definition
{
	void parse()
	{
		handle(42); // [4] non-dependent name
	}
};

void handle(int value) // [5] handle(int) definition
{
	std::cout << "processing an int: " << value << '\n';
}

int main()
{
	parser<int> p; // [6] template instantiation
	p.parse();
}
\end{lstlisting}

注释中有几个参考点。[1]处，声明了一个名为parser的类模板。然后在点[2]处定义一个名为handle的函数，该函数以double作为参数。类模板的定义在点[3]处。该类包含一个名为run的方法，该方法调用一个名为handle的函数，其参数值为42，位于点[4]。

handle是一个非依赖名称，因为它不依赖于任何模板参数。因此，此处执行名称查找和绑定。handle必须是点[3]上已知的函数，在[2]上定义的函数是唯一匹配的。在类模板定义之后(点[5]处)，我们有了函数handle的重载定义，该函数句柄以整数作为参数。这是handle(42)更好的匹配，但它是在执行名称绑定之后出现的，因此将被忽略。main函数中(点[6]处)，有int类型的解析器类模板的实例化。调用run函数时，会将"processing adouble: 42"输出至控制台。

下一个示例来介绍依赖名称的概念:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct handler // [1] template definition
{
	void handle(T value)
	{
		std::cout << "handler<T>: " << value << '\n';
	}
};

template <typename T>
struct parser // [2] template definition
{
	void parse(T arg)
	{
		arg.handle(42); // [3] dependent name
	}
};

template <>
struct handler<int> // [4] template specialization
{
	void handle(int value)
	{
		std::cout << "handler<int>: " << value << '\n';
	}
};

int main()
{
	handler<int> h; // [5] template instantiation
	parser<handler<int>> p; // [6] template instantiation
	p.parse(h);
}
\end{lstlisting}

这个示例与前面的示例略有不同。parser类模板非常相似，但是handle函数已经成为另一个类模板的成员。

注释[1]处，有一个名为handler的类模板的定义。包含一个名为handle的公共方法，该方法接受T类型的参数并将其值输出到控制台。接下来，在[2]处，有称为parser的类模板的定义。这与前一个类似，除了一个关键方面:[3]处，它在其参数上调用一个名为handle的方法。因为实参的类型是模板形参T，其使handle成为依赖名称。依赖名称在模板实例化时查找，因此句柄此时没有绑定。继续下面的代码，[4]处，有int类型的处理程序类模板的模板特化。作为特化，这是与依赖名称更好的匹配。因此，当模板实例化发生在[6]时，handler<int>::handle会绑定到[3]处，使用的依赖名称的名称。运行此程序，控制台将会输出"handler<int>: 42"。

现在已经了解了名称绑定是如何发生的，接下来来了解它与模板实例化之间的关系。

\subsubsubsection{4.1.1\hspace{0.2cm}两阶段的名称查找}

上一节的关键内容是，名称查找对于依赖名称(依赖于模板参数的名称)和非依赖名称(不依赖于模板参数的名称，加上模板名称和当前模板实例化中定义的名称)是不同的。当编译器遍历模板定义时，需要判断名称是依赖的还是非依赖的，高阶名称查找依赖于这种分类，并且发生在模板定义点(对于非依赖名称)或模板实例化点(对于依赖名称)。因此，模板的实例化会分为两个阶段:

\begin{itemize}
\item
第一个阶段发生在定义时，检查模板语法并将名称分类为依赖或非依赖。

\item
第二个阶段发生在实例化时，此时模板实参替换为模板参数。依赖名称的绑定这时发生。
\end{itemize}

这个分为两步的过程称为\textbf{两阶段名称查找}。为了更好地理解，来看一个例子:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct base_parser
{
	void init()
	{
		std::cout << "init\n";
	}
};

template <typename T>
struct parser : base_parser<T>
{
	void parse()
	{
		init(); // error: identifier not found
		std::cout << "parse\n";
	}
};

int main()
{
	parser<int> p;
	p.parse();
}
\end{lstlisting}

这段代码中，有两个类模板:base\_parser和parser，前者包含名为init的公共方法，后者派生自base\_parser，并包含一个名为parse的公共方法。parse成员函数调用了一个名为init的函数，目的是在这里调用的是基类方法init。然而，编译器将报错，因为它无法找到init。发生这种情况的原因是init是一个不依赖的名称(不依赖于模板参数)。因此，必须在定义解析器模板时就知道。尽管base\_parser<T>::init存在，但编译器不能假定它是我们想要的，因为主模板base\_parser可以稍后进行特化，而init可以定义为其他东西(例如：类型、变量或另一个函数)。因此，名称查找不会发生在基类中，而只发生在其外围作用域中，并且parser中没有名为init的函数。
 
这个问题可以通过将init设置为依赖名称来解决。这可以通过添加前缀this ->或base\_parser<T>::来实现。将init转换为依赖名称，其名称绑定将从模板定义点移动到模板实例化点。下面的代码片段中，这个问题通过this指针调用init来解决:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct parser : base_parser<T>
{
	void parse()
	{
		this->init(); // OK
		std::cout << "parse\n";
	}
};
\end{lstlisting}

继续这个例子，在定义parser类模板之后，int类型的base\_parser的特化是可用的。如下所示:

\begin{lstlisting}[style=styleCXX]
template <>
struct base_parser<int>
{
	void init()
	{
		std::cout << "specialized init\n";
	}
};
\end{lstlisting}

此外，看看parser类模板的如下用法:

\begin{lstlisting}[style=styleCXX]
int main()
{
	parser<int> p1;
	p1.parse();
	parser<double> p2;
	p2.parse();
}
\end{lstlisting}

运行这个程序时，下面的文本将输出到控制台:

\begin{tcblisting}{commandshell={}}
specialized init
parse
init
parse
\end{tcblisting}

出现这种行为的原因是p1是parser<int>的实例，并且其基类base\_parser<int>实现了init函数，并将特化的init打印到控制台。另一方面，p2是parser<double>的实例。由于double类型的base\_parser的特化不可用，因此将调用主模板中的init函数，并且只将init打印到控制台。

下一个主题就是如何使用依赖名称，即类型。

\subsubsubsection{4.1.2\hspace{0.2cm}依赖类型的名称}

目前为止的例子中，依赖名称是函数或成员函数。但在某些情况下，依赖名称是类型:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct base_parser
{
	using value_type = T;
};

template <typename T>
struct parser : base_parser<T>
{
	void parse()
	{
		value_type v{}; // [1] error
		// or
		base_parser<T>::value_type v{}; // [2] error
		std::cout << "parse\n";
	}
};
\end{lstlisting}

这个代码片段中，base\_parser是一个类模板，为T定义了一个名为value\_type的类型别名。解析器类模板派生自base\_parser，需要在其解析方法中使用这种类型。然而，value\_type和base\_parser<T>::value\_type都不起作用，编译器会报错。value\_type无效，因为它是一个不依赖的名称，因此不会在基类中进行查找，只能在外围作用域中查找。base\_parser<T>::value\_type也不能工作，因为编译器不能假设这是一个实际类型。base\_parser的特化可能紧随其后，value\_type不一定是一种类型。

为了解决这个问题，需要告诉编译器这个名称指向的类型。否则，默认情况下，编译器会假定它不是类型。这是通过typename关键字在定义点完成的，如下所示:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct parser : base_parser<T>
{
	void parse()
	{
		typename base_parser<T>::value_type v{}; // [3] OK
		std::cout << "parse\n";
	}
};
\end{lstlisting}

实际上，这条规则有两个例外:

\begin{itemize}
\item
指定基类时

\item
初始化类成员时
\end{itemize}

来看看这两个例外:

\begin{lstlisting}[style=styleCXX]
struct dictionary_traits
{
	using key_type = int;
	using map_type = std::map<key_type, std::string>;
	static constexpr int identity = 1;
};

template <typename T>
struct dictionary : T::map_type // [1]
{
	int start_key { T::identity }; // [2]
	typename T::key_type next_key; // [3]
};

int main()
{
	dictionary<dictionary_traits> d;
}
\end{lstlisting}

dictionay\_traits是一个类，用作字典类template的模板参数。这个类派生于T::map\_type(参见第[1]行)，但不需要使用typename关键字。字典类定义了一个名为start\_key的成员，它是一个int型，初始化值为T::identity(参见第[2]行)。同样，这里不需要typename关键字。然而，若想定义类型T::key\_type的另一个成员(见[3]行)，需要使用typename。

C++20中，对使用typename的要求已经放宽了，从而更容易使用类型名。编译器现在能够推断出我们在许多上下文中引用的是类型名。例如，在[3]行上那样定义成员变量时，就不再需要使用typename关键字作为前缀了。

C++20中，typename在以下情形中是隐式的(可以由编译器推导出来):

\begin{itemize}
\item
使用声明时

\item
数据成员声明中

\item
函数参数的声明或定义中

\item
尾部返回类型中

\item
模板类型参数的默认类型中

\item
static\_cast、const\_cast、reinterpret\_cast或dynamic\_cast语句的type-id中
\end{itemize}

以下代码段举例说明了其中一些情况:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct dictionary : T::map_type
{
	int start_key{ T::identity };
	T::key_type next_key; // [1]
	
	using value_type = T::map_type::mapped_type; // [2]
	
	void add(T::key_type const&, value_type const&) {} // [3]
};
\end{lstlisting}

这个代码片段中，[1]、[2]和[3]标记的所有行中，C++20之前，需要typename关键字来指示类型名称(例如T::key\_type或T::map\_type::mapped\_type)。当使用C++20编译时，这就不再需要了。

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={Note}]
第2章中，我们已经看到关键字typename和class可以用来引入类型模板参数，而且是可互换的。这里的关键字typename虽然具有类似的使用方式，但不能用class替换。
\end{tcolorbox}

不仅类型可以是依赖的名称，其他模板也可以。

\subsubsubsection{4.1.3\hspace{0.2cm}依赖模板的名称}

There are cases when the dependent name is a template, such as a function template or a class template. However, the default behavior of the compiler is to interpret the dependent name as a non-type, which leads to errors concerning the usage of the comparison operator <. Let’s demonstrate this with an example:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct base_parser
{
	template <typename U>
	void init()
	{
		std::cout << "init\n";
	}
};

template <typename T>
struct parser : base_parser<T>
{
	void parse()
	{
		// base_parser<T>::init<int>(); // [1] error
		base_parser<T>::template init<int>(); // [2] OK
		std::cout << "parse\n";
	}
};
\end{lstlisting}

This is similar to the previous snippets, but the init function in base\_parser is also a template. The attempt to call it using the base\_parser<T>::init<int>() syntax, as seen at point [1], results in a compiler error. Therefore, we must use the template keyword to tell the compiler the dependent name is a template. This is done as shown at point [2].

Keep in mind that the template keyword can only follow the scope resolution operator (::), member access through pointer (->), and the member access (.). Examples of correct usage are X::template foo<T>(), this->template foo<T>(), and obj.template foo<T>().

The dependent name does not have to be a function template. It can also be a class template, shown as follows:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct base_parser
{
	template <typename U>
	struct token {};
};

template <typename T>
struct parser : base_parser<T>
{
	void parse()
	{
		using token_type =
			base_parser<T>::template token<int>; // [1]
		token_type t1{};
		
		typename base_parser<T>::template token<int> t2{};
		                     // [2]
		std::cout << "parse\n";
	}
};
\end{lstlisting}

The token class is an inner class template of the base\_parser class template. It can be either used as in the line marked with [1], where a type alias is defined (which is then used to instantiate an object) or as at line [2], where it is used directly to declare a variable. Notice that the typename keyword is not necessary at [1], where the using declaration indicates we are dealing with a type, but is required at [2] because the compiler would otherwise assume it’s a non-type name.

The use of the typename and template keywords is not required in some contexts of the current template instantiation being observed. This will be the topic of the next subsection.

\subsubsubsection{4.1.4\hspace{0.2cm}实例化}

The requirement to use the typename and template keywords to disambiguate dependent names may be avoided in the context of a class template definition where the compiler is able to deduce some dependent names (such as the name of a nested class) to refer to the current instantiation. This means some errors can be identified sooner, at the point of definition instead of the point of instantiation.

The complete list of names that can refer to the current instantiation, according to the C++ Standard, §13.8.2.1 - Dependent Types, is presented in the following table:

\begin{table}[H]
\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Context} &
		\textbf{Names} \\ \hline
		Class template definition &
		\begin{tabular}[c]{@{}l@{}}Nested class\\ Member of class template\\ Member of a nested class\\ Injected class-name of the template\\ Injected class-name of a nested class\end{tabular} \\ \hline
		\begin{tabular}[c]{@{}l@{}}Primary class template definition\\ or\\ Definition of members of a \\ primary class template\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}Name of the class template followed by a template\\ argument list for the primary template where\\ each argument is equivalent to its corresponding\\ parameter\end{tabular} \\ \hline
		\begin{tabular}[c]{@{}l@{}}Definition of a nested class or\\ class template\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}Name of a nested class used as a member of the\\ current instantiation\end{tabular} \\ \hline
		\begin{tabular}[c]{@{}l@{}}Definition of a partial\\ specialization\\ or\\ Definition of a member of a\\ partial specialization\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}Name of the class template followed by a template\\ argument list for the partial specialization, where\\ each argument is equivalent to its corresponding\\ parameter\end{tabular} \\ \hline
	\end{tabular}
\end{table}

\begin{center}
Table 4.1
\end{center}

The following are the rules for considering a name as part of the current instantiation:

\begin{itemize}
\item
An unqualified name (that does not appear on the right side of the scope resolution operator ::) found in the current instantiation or its non-dependent base

\item
A qualified name (that appears on the right side of the scope resolution operator ::) if its qualifier (the part that appears on the left side of the scope resolution operator) names the current instantiation and is found in the current instantiation or its non-dependent base

\item
A name used in a class member access expression where the object expression is the current instantiation and the name is found in the current instantiation or its non-dependent base
\end{itemize}

\begin{tcolorbox}[breakable,enhanced jigsaw,colback=blue!5!white,colframe=blue!75!black,title={Note}]
It is said that a base class is a dependent class if it is a dependent type (depends on a template parameter) and is not in the current instantiation. Otherwise, a base class is said to be a non-dependent class.
\end{tcolorbox}

These rules may sound a bit harder to comprehend; therefore, let’s try to understand them with the help of several examples, as follows:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct parser
{
	parser* p1; // parser is the CI
	parser<T>* p2; // parser<T> is the CI
	::parser<T>* p3; // ::parser<T> is the CI
	parser<T*> p4; // parser<T*> is not the CI
	
	struct token
	{
		token* t1; // token is the CI
		parser<T>::token* t2; // parser<T>::token is the CI
		typename parser<T*>::token* t3;
		// parser<T*>::token is not the CI
	};
};

template <typename T>
struct parser<T*>
{
	parser<T*>* p1; // parser<T*> is the CI
	parser<T>* p2; // parser<T> is not the CI
};
\end{lstlisting}

In the primary template parser, the names parser, parser<T>, and ::parser<T> all refer to the current instantiation. However, parser<T*> does not. The class token is a nested class of the primary template parser. In the scope of this class, token and parser<T>::token are both denoting the current instantiation. The same is not true for parser<T*>::token. This snippet also contains a partial specialization of the primary template for the pointer type T*. In the context of this partial specialization, parser<T*> is the current instantiation, but parser<T> is not.

Dependent names are an important aspect of template programming. The key takeaway from this section is that names are categorized as dependent (those that depend on a template parameter) and non-dependent (those that don’t depend on a template parameter). Name binding happens at the point of definition for non-dependent types and at the point of instantiation for dependent types. In some cases, the keywords typename and template are required to disambiguate the use of names and tell the compiler that a name refers to a type or a template. In the context of a class template definition, the compiler is, however, able to figure out that some dependent names refer to the current instantiation, which enables it to identify errors sooner.

In the next section, we move our attention to a topic that we briefly touched already, which is template recursion.























