Before C++17, template argument deduction only worked for functions but not classes. This meant that when a class template had to be instantiated, all the template arguments had to be supplied. The following snippet shows several examples:

\begin{lstlisting}[style=styleCXX]
	template <typename T>
	struct wrapper
	{
		T data;
	};
	
	std::pair<int, double> p{ 42, 42.0 };
	std::vector<int> v{ 1,2,3,4,5 };
	wrapper<int> w{ 42 };
\end{lstlisting}

By leveraging template argument deduction for function templates, some standard types feature helper functions that create an instance of the type without the need to explicitly specify template arguments. Such examples are std::make\_pair for std::pair and std::make\_unique for std::unique\_ptr. These helper function templates, used in corroboration with the auto keyword, avoid the need for specifying template arguments for class templates. Here is an example:

\begin{lstlisting}[style=styleCXX]
	auto p = std::make_pair(42, 42.0);
\end{lstlisting}

Although not all standard class templates have such a helper function for creating instances, it’s not hard to write your own. In the following snippet, we can see a make\_vector function template used to create a std::vector<T> instance, and a make\_wrapper function template to create a wrapper<T> instance:

\begin{lstlisting}[style=styleCXX]
	template <typename T, typename... Ts,
	typename Allocator = std::allocator<T>>
	auto make_vector(T&& first, Ts&&... args)
	{
		return std::vector<std::decay_t<T>, Allocator> {
			std::forward<T>(first),
			std::forward<Ts>(args)...
		};
	}
	
	template <typename T>
	constexpr wrapper<T> make_wrapper(T&& data)
	{
		return wrapper{ data };
	}
	
	auto v = make_vector(1, 2, 3, 4, 5);
	auto w = make_wrapper(42);
\end{lstlisting}

The C++17 standard has simplified the use of class templates by providing template argument deduction for them. Therefore, as of C++17, the first snippet shown in this section can be simplified as follows:

\begin{lstlisting}[style=styleCXX]
	std::pair p{ 42, 42.0 }; // std::pair<int, double>
	std::vector v{ 1,2,3,4,5 }; // std::vector<int>
	wrapper w{ 42 }; // wrapper<int>
\end{lstlisting}

This is possible because the compiler is able to deduce the template arguments from the type of the initializers. In this example, the compiler deduced it from the initializing expression of the variables. But the compiler is also able to deduce template arguments from new expressions and function-style cast expressions. These are exemplified next:

\begin{lstlisting}[style=styleCXX]
	template <typename T>
	struct point_t
	{
		point_t(T vx, T vy) : x(vx), y(vy) {}
		private:
		T x;
		T y;
	};
	
	auto p = new point_t(1, 2); // [1] point<int>
	// new expression
	std::mutex mt;
	auto l = std::lock_guard(mt); // [2]
	// std::lock_guard<std::mutex>
	// function-style cast expression
\end{lstlisting}

The way template argument deduction works for class templates is different than for function templates but it relies on the latter. When encountering the name of a class template in a variable declaration or function-style cast, the compiler proceeds to build a set of so-called deduction guides.

There are fictional function templates representing constructor signatures of a fictional class type. Users can also provide deduction guides and these are added to the list of compiler-generated guides. If overload resolution fails on the constructed set of fictional function templates (the return type is not part of the matching process since these functions represent constructors), then the program is ill-formed and an error is generated. Otherwise, the return type of the selected function template specialization becomes the deduced class template specialization.

To understand this better, let’s see how the deduction guides actually look. In the following snippet, you can see some of the guides generated by the compiler for the std::pair class. The actual list is longer and, for brevity, only some are presented here:

\begin{lstlisting}[style=styleCXX]
	template <typename T1, typename T2>
	std::pair<T1, T2> F();
	
	template <typename T1, typename T2>
	std::pair<T1, T2> F(T1 const& x, T2 const& y);
	
	template <typename T1, typename T2, typename U1,
	typename U2>
	std::pair<T1, T2> F(U1&& x, U2&& y);
\end{lstlisting}

This set of implicitly deduced guides is generated from the constructors of the class template. This includes the default constructor, the copy constructor, the move constructor, and all the conversion constructors, with the arguments copied in the exact order. If the constructor is explicit, then so is the deduction guide. However, if the class template does not have any user-defined constructor, a deduction guide is created for a hypothetical default constructor. A deduction guide for a hypothetical copy constructor is always created.

User-defined deduction guides can be provided in the source code. The syntax is similar to that of functions with a trailing return type but without the auto keyword. Deduction guides can be either functions or function templates. What is important to keep in mind is that these must be provided in the same namespace as the class template they apply to. Therefore, if we were to add a user-defined deduction guide for the std::pair class, it must be done in the std namespace. An example is shown here:

\begin{lstlisting}[style=styleCXX]
	namespace std
	{
		template <typename T1, typename T2>
		pair(T1&& v1, T2&& v2) -> pair<T1, T2>;
	}
\end{lstlisting}

The deduction guides shown so far were all function templates. But as mentioned earlier, they don’t have to be function templates. They can be regular functions too. To demonstrate this, let’s consider the following example:

\begin{lstlisting}[style=styleCXX]
	std::pair p1{1, "one"}; // std::pair<int, const char*>
	std::pair p2{"two", 2}; // std::pair<const char*, int>
	std::pair p3{"3", "three"};
	// std::pair<const char*, const char*>
\end{lstlisting}

With the compiler-degenerated deduction guides for the std::pair class, the deduced types are std::pair<int, const char*> for p1, std::pair<const char*, int> for p2, and std::pair<const char*, const char*> for p3. In other words, the type deduced by the compiler where literal strings are used is const char* (as one should expect). We could tell the compiler to deduce std::string instead of const char* by providing several user-defined deduction guides. These are shown in the following listing:

\begin{lstlisting}[style=styleCXX]
	namespace std
	{
		template <typename T>
		pair(T&&, char const*) -> pair<T, std::string>;
		
		template <typename T>
		pair(char const*, T&&) -> pair<std::string, T>;
		
		pair(char const*, char const*) ->
		pair<std::string, std::string>;
	}
\end{lstlisting}

Notice that the first two are function templates, but the third one is a regular function. Having these guides available, the deduced types for p1, p2, and p3 from the previous example are std::pair<int, std::string>, std::pair<std::string, int> and std::pair<std::string, std::string> respectively.

Let’s look at one more example for user-defined guides, this time for a user-defined class. Let’s consider the following class template that models a range:

\begin{lstlisting}[style=styleCXX]
	template <typename T>
	struct range_t
	{
		template <typename Iter>
		range_t(Iter first, Iter last)
		{
			std::copy(first, last, std::back_inserter(data));
		}
		private:
		std::vector<T> data;
	};
\end{lstlisting}

There is not much to this implementation but, in fact, it is enough for our purpose. Let’s consider you want to construct a range object from an array of integers:

\begin{lstlisting}[style=styleCXX]
	int arr[] = { 1,2,3,4,5 };
	range_t r(std::begin(arr), std::end(arr));
\end{lstlisting}

\begin{tcblisting}{commandshell={}}
	error: no viable constructor or deduction guide for deduction
	of template arguments of 'range_t'
	range_t r(std::begin(arr), std::end(arr));
	^
	note: candidate template ignored: couldn't infer template
	argument 'T'
	range_t(Iter first, Iter last)
	^
	note: candidate function template not viable: requires 1
	argument, but 2 were provided
	struct range_t
\end{tcblisting}

Nevertheless, regardless of what the actual error message is, the meaning is the same: template argument deduction for range\_t failed. In order to make deduction work, a user-defined deduction guide needs to be provided and it needs to look as follows:

\begin{lstlisting}[style=styleCXX]
	template <typename Iter>
	range_t(Iter first, Iter last) ->
	range_t<
	typename std::iterator_traits<Iter>::value_type>;
\end{lstlisting}

What this deduction guide is instructing is that when a call to the constructor with two iterator arguments is encountered, the value of the template parameter T should be deduced to be the value type of the iterator traits. Iterator traits is a topic that will be addressed in Chapter 5, Type Traits and Conditional Compilation. However, with this available, the previous snippet runs without problems and the compiler deduces the type of the r variable to be range\_t<int>, as intended.

At the beginning of this section, the following example was provided, where the type of w was said to be deduced as wrapper<int>:

\begin{lstlisting}[style=styleCXX]
	wrapper w{ 42 }; // wrapper<int>
\end{lstlisting}

In C++17, this is not actually true without a user-defined deduction guide. The reason is that wrapper<T> is an aggregate type and class template argument deduction does not work from aggregate initialization in C++17. Therefore, to make the preceding line of code work, a deduction guide as follows needs to be provided:

\begin{lstlisting}[style=styleCXX]
	template <typename T>
	wrapper(T) -> wrapper<T>;
\end{lstlisting}

Fortunately, the need for such a user-defined deduction guide was removed in C++20. This version of the standard provides support for aggregate types (as long as any dependent base class has no virtual functions or virtual base classes and the variable is initialized from a non-empty list of initializers).
Class template argument deduction only works if no template arguments are provided.

As a consequence, the following declarations of p1 and p2 are both valid and class template argument deduction occurs; for p2, the deduced type is std::pair<int, std::string> (assuming the previously user-defined guides are available). However, the declarations of p3 and p4 produce an error because class template argument deduction does not occur, since a template argument list is present (<> and <int>) but does not contain all required arguments:

\begin{lstlisting}[style=styleCXX]
	std::pair<int, std::string> p1{ 1, "one" }; // OK
	std::pair p2{ 2, "two" }; // OK
	std::pair<> p3{ 3, "three" }; // error
	std::pair<int> p4{ 4, "four" }; // error
\end{lstlisting}

Class template argument deduction may not always produce the expected results. Let’s consider the following example:

\begin{lstlisting}[style=styleCXX]
	std::vector v1{ 42 };
	std::vector v2{ v1, v1 };
	std::vector v3{ v1 };
\end{lstlisting}

The deduced type for v1 is std::vector<int> and the deduced type for v2 is std::vector<std::vector<int>>. However, what should the compiler deduce for the type of v3? There are two options: std::vector<std::vector<int>> and std::vector<int>. If your expectation is the former, you will be disappointed to learn that the compiler actually deduces the latter. This is because deduction depends on both the number of arguments and their type.

When the number of arguments is greater than one, it will use the constructor that takes an initializer list. For the v2 variable, that is std::initializer\_list<std::vector<int>>. When the number of arguments is one, then the type of the arguments is considered. If the type of the argument is a (specialization of) std::vector – considering this explicit case – then the copy-constructor is used and the deduced type is the declared type of the argument. This is the case of variable v3, where the deduced type is std::vector<int>. Otherwise, the constructor that takes an initializer list (with a single element) is used, as in the case of variable v1, for which the deduced type is std::vector<int>. These could be better visualized with the help of the cppinsights.io tool, which shows the following generated code (for the previous snippet). Notice that the allocator argument has been removed for brevity:

\begin{lstlisting}[style=styleCXX]
	std::vector<int> v1 =
	std::vector<int>{std::initializer_list<int>{42}};
	std::vector<vector<int>> v2 =
	std::vector<vector<int>>{
		std::initializer_list<std::vector<int>>{
			std::vector<int>(v1),
			std::vector<int>(v1)
		}
	};
	
	std::vector<int> v3 = std::vector<int>{v1};
\end{lstlisting}

Class template argument deduction is a useful feature of C++17 with improvements for aggregate types in C++20. It helps avoid writing unnecessary explicit template arguments when the compiler is able to deduce them, even though, in some cases, the compiler may require user-defined deduction guides for the deduction to work. It also avoids the need for creating factory functions, such as std::make\_pair or std::make\_tuple, that were a workaround for benefiting from template argument deduction before it was available for class templates.

There is more to template argument deduction than what we have discussed so far. There is a special case of function template argument deduction known as forwarding references. This will be addressed next.







