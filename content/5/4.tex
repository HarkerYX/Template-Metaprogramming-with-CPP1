\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Question 1}

When is name lookup performed?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Answer}

Name lookup is performed at the point of template instantiation for dependent names (those that depend on the type or value of a template parameter) and at the point of template definition for non-dependent names (those that don’t depend on template parameters).


\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Question 2}

What are deduction guides?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Answer}

Deduction guides are a mechanism that tells the compiler how to perform class template argument deduction. Deduction guides are fictional function templates representing constructor signatures of a fictional class type. If overload resolution fails on the constructed set of fictional function templates, then the program is ill-formed and an error is generated. Otherwise, the return type of the selected function template specialization becomes the deduced class template specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Question 3}

What are forwarding references?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Answer}

A forward reference (also known as universal reference) is a reference in a template that behaves as an rvalue reference if an rvalue was passed as an argument or an lvalue reference if an lvalue was passed as an argument. A forwarding reference must have the T\&\& form such as in template <typename T> void f(T\&\&). Forms such as T const \&\& or std::vector<T>\&\& do not represent forwarding references but normal rvalue references.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Question 4}

What does decltype do?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Answer}

The decltype specifier is a type specifier. It returns the type of an expression. It is usually used in templates together with the auto specifier in order to declare the return type of a function template that depends on its template arguments, or the return type of a function that wraps another function and returns the result from executing the wrapped function.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Question 5}

What does std::declval do?

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Answer}

std::declval is a utility function template from the <utility> header that adds an rvalue reference to its type template argument. It can only be used in unevaluated contexts (compile-time-only contexts that are not evaluated during runtime), and its purpose is to help with dependent type evaluation for types that do not have a default constructor or one that cannot be accessed because it’s private or protected.












