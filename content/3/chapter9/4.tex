The standard library contains a series of range adaptors that can be used for solving many different tasks. More are being added in newer versions of the standard. However, there can be situations when you’d like to create your own range adaptor to use with others from the range library. This is not actually a trivial task. For this reason, in this final section of the chapter, we will explore the steps you need to follow to write such a range adaptor.

For this purpose, we will consider a range adaptor that takes every Nth element of a range and skips the others. We will call this adaptor step\_view. We can use it to write code as follows:

\begin{lstlisting}[style=styleCXX]
for (auto i : std::views::iota(1, 10) | views::step(1))
	std::cout << i << '\n';

for (auto i : std::views::iota(1, 10) | views::step(2))
	std::cout << i << '\n';

for (auto i : std::views::iota(1, 10) | views::step(3))
	std::cout << i << '\n';

for (auto i : std::views::iota(1, 10) | views::step(2) | 	
				std::views::take(3))
	std::cout << i << '\n';
\end{lstlisting}

The first loop will print all the numbers from one to nine. The second loop will print all the odd numbers, 1, 3, 5, 7, 9. The third loop will print 1, 4, 7. Lastly, the fourth loop will print 1, 3, 5.

To make this possible, we need to implement the following entities:

\begin{itemize}
\item
A class template that defines the range adaptor

\item
A deduction guide to help with class template argument deduction for the range adaptor

\item
A class template that defines the iterator type for the range adaptor

\item
A class template that defines the sentinel type for the range adaptor

\item
An overloaded pipe operator (|) and helper functors, required for its implementation

\item
A compile-time constant global object to simplify the use of the range adaptor
\end{itemize}

Let’s take them one by one and learn how to define them. We’ll start with the sentinel class. A sentinel is an abstraction of a past-the-end iterator. It allows us to check whether an iteration reached the end of a range. A sentinel makes it possible for the end iterator to have a different type than the range iterators. Sentinels cannot be dereferenced or incremented. Here is how it can be defined:

\begin{lstlisting}[style=styleCXX]
template <typename R>
struct step_iterator;

template <typename R>
struct step_sentinel
{
	using base = std::ranges::iterator_t<R>;
	using size_type = std::ranges::range_difference_t<R>;
	
	step_sentinel() = default;
	
	constexpr step_sentinel(base end) : end_{ end } {}
	constexpr bool is_at_end(step_iterator<R> it) const;
	
private:
	base end_;
};

// definition of the step_iterator type

template <typename R>
constexpr bool step_sentinel<R>::is_at_end(
	step_iterator<R> it) const
{
	return end_ == it.value();
}
\end{lstlisting}

The sentinel is constructed from an iterator and contains a member function called is\_at\_end that checks whether the stored range iterator is equal to the range iterator stored in a step\_iterator object. This type, step\_iterator, is a class template that defines the iterator type for our range adaptor, which we call step\_view. Here is an implementation of this iterator type:

\begin{lstlisting}[style=styleCXX]
template <typename R>
struct step_iterator : std::ranges::iterator_t<R>
{
	using base
		= std::ranges::iterator_t<R>;
	using value_type
		= typename std::ranges::range_value_t<R>;
	using reference_type
		= typename std::ranges::range_reference_t<R>;
		
	constexpr step_iterator(
		base start, base end,
		std::ranges::range_difference_t<R> step) :
		pos_{ start }, end_{ end }, step_{ step }
	{
	}

	constexpr step_iterator operator++(int)
	{
		auto ret = *this;
		pos_ = std::ranges::next(pos_, step_, end_);
		return ret;
	}

	constexpr step_iterator& operator++()
	{
		pos_ = std::ranges::next(pos_, step_, end_);
		return *this;
	}

	constexpr reference_type operator*() const
	{
		return *pos_;
	}
	constexpr bool operator==(step_sentinel<R> s) const
	{
		return s.is_at_end(*this);
	}

	constexpr base const value() const { return pos_; }
	
private:
	base pos_;
	base end_;
	std::ranges::range_difference_t<R> step_;
};
\end{lstlisting}

This type must have several members:

\begin{itemize}
\item
The alias template called base that represents the type of the underlying range iterator.

\item
The alias template called value\_type that represents the type of elements of an underlying range.

\item
The overloaded operators ++ and *.

\item
The overloaded operator == compares this object with a sentinel.
\end{itemize}

The implementation of the ++ operator uses the std::ranges::next constrained algorithm to increment an iterator with N positions, but not past the end of the range.

In order to use the step\_iterator and step\_sentinel pair for the step\_view range adaptor, you must make sure this pair is actually well-formed. For this, we must ensure that the step\_iterator type is an input iterator, and that the step\_sentinel type is indeed a sentinel type for the step\_iterator type. This can be done with the help of the following static\_assert statements:

\begin{lstlisting}[style=styleCXX]
namespace details
{
	using test_range_t =
		std::ranges::views::all_t<std::vector<int>>;
	static_assert(
		std::input_iterator<step_iterator<test_range_t>>);
	static_assert(
		std::sentinel_for<step_sentinel<test_range_t>,
		step_iterator<test_range_t>>);
}
\end{lstlisting}

The step\_iterator type is used in the implementation of the step\_view range adaptor. At a minimum, this could look as follows:

\begin{lstlisting}[style=styleCXX]
template<std::ranges::view R>
struct step_view :
	public std::ranges::view_interface<step_view<R>>
{
private:
	R base_;
	std::ranges::range_difference_t<R> step_;
	
public:
	step_view() = default;
	
	constexpr step_view(
		R base,
		std::ranges::range_difference_t<R> step)
			: base_(std::move(base))
			, step_(step)
	{
	}

	constexpr R base() const&
		requires std::copy_constructible<R>
	{ return base_; }
	constexpr R base()&& { return std::move(base_); }
	
	constexpr std::ranges::range_difference_t<R> const&
	increment() const
	{ return step_; }
	
	constexpr auto begin()
	{
		return step_iterator<R const>(
			std::ranges::begin(base_),
			std::ranges::end(base_), step_);
	}

	constexpr auto begin() const
	requires std::ranges::range<R const>
	{
		return step_iterator<R const>(
			std::ranges::begin(base_),
			std::ranges::end(base_), step_);
	}

	constexpr auto end()
	{
		return step_sentinel<R const>{
			std::ranges::end(base_) };
	}

	constexpr auto end() const
	requires std::ranges::range<R const>
	{
		return step_sentinel<R const>{
			std::ranges::end(base_) };
	}

	constexpr auto size() const
	requires std::ranges::sized_range<R const>
	{
		auto d = std::ranges::size(base_);
		return step_ == 1 ? d :
			static_cast<int>((d + 1)/step_); 
	}
	
	constexpr auto size()
	requires std::ranges::sized_range<R>
	{
		auto d = std::ranges::size(base_);
		return step_ == 1 ? d :
			static_cast<int>((d + 1)/step_);
	}
};
\end{lstlisting}

There is a pattern that must be followed when defining a range adaptor. This pattern is represented by the following aspects:

\begin{itemize}
\item
The class template must have a template argument that meets the std::ranges::view concept.

\item
The class template should be derived from std::ranges:view\_interface. This takes a template argument itself and that should be the range adaptor class. This is basically an implementation of the CRTP that we learned about in Chapter 7, Patterns and Idioms.

\item
The class must have a default constructor.

\item
The class must have a base member function that returns the underlying range.

\item
The class must have a begin member function that returns an iterator to the first element in the range.

\item
The class must have an end member function that returns either an iterator to the one-past-the-last element of the range or a sentinel.

\item
For ranges that meet the requirements of the std::ranges::sized\_range concept, this class must also contain a member function called size that returns the number of elements in the range.
\end{itemize}

In order to make it possible to use class template argument deduction for the step\_view class, a user-defined deduction guide should be defined. These were discussed in Chapter 4, Advanced Template Concepts. Such a guide should look as follows:

\begin{lstlisting}[style=styleCXX]
template<class R>
step_view(R&& base,
		  std::ranges::range_difference_t<R> step)
	-> step_view<std::ranges::views::all_t<R>>;
\end{lstlisting}

In order to make it possible to compose this range adaptor with others using the pipe iterator (|), this operator must be overloaded. However, we need some helper function object, which is shown in the next listing:

\begin{lstlisting}[style=styleCXX]
namespace details
{
	struct step_view_fn_closure
	{
		std::size_t step_;
		constexpr step_view_fn_closure(std::size_t step)
			: step_(step)
		{
		}
	
		template <std::ranges::range R>
		constexpr auto operator()(R&& r) const
		{
			return step_view(std::forward<R>(r), step_);
		}
	};
	template <std::ranges::range R>
	constexpr auto operator | (R&& r,
								step_view_fn_closure&& a)
	{
		return std::forward<step_view_fn_closure>(a)(
			std::forward<R>(r));
	}
}
\end{lstlisting}

The step\_view\_fn\_closure class is a function object that stores a value representing the number of elements to skip for each iterator. Its overloaded call operator takes a range as an argument and returns a step\_view object created from the range and the value for the number of steps to jump.

Finally, we want to make it possible to write code in a similar manner to what is available in the standard library, which provides a compile-time global object in the std::views namespace for each range adaptor that exists. For instance, instead of std::ranges::transform\_view, you could use std::views::transform. Similarly, instead of step\_view (in some namespace), we want to have an object, views::step. To do so, we need yet another function object, as shown next:

\begin{lstlisting}[style=styleCXX]
namespace details
{
	struct step_view_fn
	{
		template<std::ranges::range R>
		constexpr auto operator () (R&& r,
								    std::size_t step) const
		{
			return step_view(std::forward<R>(r), step);
		}
	
		constexpr auto operator () (std::size_t step) const
		{
			return step_view_fn_closure(step);
		}
	};
}

namespace views
{
	inline constexpr details::step_view_fn step;
}
\end{lstlisting}

The step\_view\_fn type is a function object that has two overloads for the call operator: one takes a range and an integer and returns a step\_view object, and the other takes an integer and returns a closure for this value, or, more precisely, an instance of step\_view\_fn\_closure that we saw earlier.

Having all these implemented, we can successfully run the code shown at the beginning of this section. We have completed the implementation of a simple range adaptor. Hopefully, this should give you a sense of what writing range adaptors takes. The ranges library is significantly complex when you look at the details. In this chapter, you have learned some basics about the content of the library, how it can simplify your code, and how you can extend it with custom features. This knowledge should be a starting point for you should you want to learn more using other resources.






























