The standard library provides over one hundred general-purpose algorithms. As we discussed in the introductory section for the ranges library earlier, these have one thing in common: they work with abstract ranges with the help of iterators. They take iterators as arguments and they sometimes return iterators. That makes it cumbersome to repeatedly use with standard containers or arrays. Here is an example:

\begin{lstlisting}[style=styleCXX]
auto l_odd = [](int const n) {return n % 2 == 1; };

std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };
std::vector<int> o;
auto e1 = std::copy_if(v.begin(), v.end(),
						std::back_inserter(o),
						l_odd);
						
int arr[] = { 1, 1, 2, 3, 5, 8, 13 };
auto e2 = std::copy_if(std::begin(arr), std::end(arr),
						std::back_inserter(o),
						l_odd);
\end{lstlisting}

In this snippet, we have a vector v and an array arr, and we copy the odd elements from each of these two to a second vector, o. For this, the std::copy\_if algorithm is used. This takes begin and end input iterators (defining the input range), an output iterator to a second range, where the copied elements will be inserted, and a unary predicate (in this example, a lambda expression). What it returns is an iterator to the destination range past the last copied element.

If we look at the declaration of the std::copy\_if algorithm, we will find the following two overloads:

\begin{lstlisting}[style=styleCXX]
template <typename InputIt, typename OutputIt,
		  typename UnaryPredicate>
constexpr OutputIt copy_if(InputIt first, InputIt last,
						   OutputIt d_first,
						   UnaryPredicate pred);
						   
template <typename ExecutionPolicy,
		  typename ForwardIt1, typename ForwardIt2,
		  typename UnaryPredicate>
ForwardIt2 copy_if(ExecutionPolicy&& policy,
				   ForwardIt1 first, ForwardIt1 last,
				   ForwardIt2 d_first,
				   UnaryPredicate pred);
\end{lstlisting}

The first overload is the one used and described here. The second overload was introduced in C++17. This allows you to specify an execution policy such as parallel or sequential.
This basically enables the parallel execution of the standard algorithms. However, this is not relevant to the topic of this chapter, and we will not explore it further.

Most of the standard algorithms have a new constrained version in the std::ranges namespace. These algorithms are found in the <algorithm>, <numeric>, and <memory> headers and have the following traits:

\begin{itemize}
\item
They have the same name as the existing algorithms.

\item
They have overloads that allow you to specify a range, either with a begin iterator and an end sentinel, or as a single range argument.

\item
They have modified return types that provide more information about the execution.

\item
They support projections to apply to the processed elements. A projection is an entity that can be invoked. It can be a pointer to a member, a lambda expression, or a function pointer. Such a projection is applied to the range element before the algorithm logic uses the element.
\end{itemize}

Here is how the overloads of the std::ranges::copy\_if algorithm are declared:

\begin{lstlisting}[style=styleCXX]
template <std::input_iterator I,
		  std::sentinel_for<I> S,
		  std::weakly_incrementable O,
		  class Proj = std::identity,
		  std::indirect_unary_predicate<
		    std::projected<I, Proj>> Pred>
requires std::indirectly_copyable<I, O>
constexpr copy_if_result<I, O> copy_if(I first, S last,
									   O result,
								   	   Pred pred,
									   Proj proj = {} );
									   
template <ranges::input_range R,
		  std::weakly_incrementable O,
		  class Proj = std::identity,
		  std::indirect_unary_predicate<
		  std::projected<ranges::iterator_t<R>, Proj>> Pred>
requires std::indirectly_copyable<ranges::iterator_t<R>, O>
constexpr copy_if_result<ranges::borrowed_iterator_t<R>, O>
		  copy_if(R&& r,
				  O result,
				  Pred pred,
				  Proj proj = {});
\end{lstlisting}

If these seem more difficult to read, it is because they have more arguments, constraints, and longer type names. The good part, however, is that they make the code easier to write. Here is the previous snippet rewritten to use std::ranges::copy\_if:

\begin{lstlisting}[style=styleCXX]
std::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };
std::vector<int> o;
auto e1 = std::ranges::copy_if(v, std::back_inserter(o),
								l_odd);
								
int arr[] = { 1, 1, 2, 3, 5, 8, 13 };
auto e2 = std::ranges::copy_if(arr, std::back_inserter(o),
								l_odd);

auto r = std::ranges::views::iota(1, 10);
auto e3 = std::ranges::copy_if(r, std::back_inserter(o),
								l_odd);
\end{lstlisting}

These examples show two things: how to copy elements from a std::vector object and an array and how to copy elements from a view (a range adaptor). What they don’t show is projections. This was briefly mentioned earlier. We’ll discuss it with more details and examples here.

A projection is an invocable entity. It’s basically a function adaptor. It affects the predicate, providing a way to perform function composition. It does not provide a way to change the algorithm. For instance, let’s say we have the following type:

\begin{lstlisting}[style=styleCXX]
struct Item
{
	int id;
	std::string name;
	double price;
};
\end{lstlisting}

Also, for the purpose of the explanation, let’s also consider the following sequence of elements:

\begin{lstlisting}[style=styleCXX]
std::vector<Item> items{
	{1, "pen", 5.49},
	{2, "ruler", 3.99},
	{3, "pensil case", 12.50}
};
\end{lstlisting}

Projections allow you to perform composition on the predicate. For instance, let’s say we want to copy to a second vector all the items whose names begin with the letter p. We can write the following:

\begin{lstlisting}[style=styleCXX]
std::vector<Item> copies;
std::ranges::copy_if(
	items,
	std::back_inserter(copies),
	[](Item const& i) {return i.name[0] == 'p'; });
\end{lstlisting}

However, we can also write the following equivalent example:

\begin{lstlisting}[style=styleCXX]
std::vector<Item> copies;
std::ranges::copy_if(
	items,
	std::back_inserter(copies),
	[](std::string const& name) {return name[0] == 'p'; },
	&Item::name);
\end{lstlisting}

The projection, in this example, is the pointer-to-member expression \&Item::name that is applied to each Item element before executing the predicate (which is a lambda expression here). This can be useful when you already have reusable function objects or lambda expressions and you don’t want to write another one for passing different types of arguments.

What projects cannot be used for, in this manner, is transforming a range from one type into another. For instance, you cannot just copy the names of the items from std::vector<Item> to std::vector<std::string>. This requires the use of the std::ranges::transform range adaptor, as shown in the following snippet:

\begin{lstlisting}[style=styleCXX]
std::vector<std::string> names;
std::ranges::copy_if(
	items | rv::transform(&Item::name),
	std::back_inserter(names),
	[](std::string const& name) {return name[0] == 'p'; });
\end{lstlisting}

There are many constrained algorithms, but we will not list them here. Instead, you can check them all either directly in the standard, or on the \url{https://en.cppreference.
com/w/cpp/algorithm/ranges} page.

The last topic that we’ll address in this chapter is writing a custom range adaptor.




























