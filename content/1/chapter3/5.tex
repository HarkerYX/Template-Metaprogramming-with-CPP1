折叠表达式是一种包含参数包的表达式，它将参数包中的元素折叠(或减少)到二进制运算符上。为了了解其工作原理，我们可以来看几个例子。之前，我们实现了一个名为sum的变量函数模板，返回所有提供参数的和。方便起见，我们将在这里再次展示:

\begin{lstlisting}[style=styleCXX]
template <typename T>
T sum(T a)
{
	return a;
}

template <typename T, typename... Args>
T sum(T a, Args... args)
{
	return a + sum(args...);
}
\end{lstlisting}

使用折叠表达式，需要两次重载的实现可以简化为以下形式:

\begin{lstlisting}[style=styleCXX]
template <typename... T>
int sum(T... args)
{
	return (... + args);
}
\end{lstlisting}

不再需要重载函数了。表达(…+ args)表示折叠表达式，计算后变为((((arg0 + arg1) + arg2) +…)+ argN)。括号是折叠表达式的一部分，可以使用这个新的实现，就像使用最初的实现一样:

\begin{lstlisting}[style=styleCXX]
int main()
{
	std::cout << sum(1) << '\n';
	std::cout << sum(1,2) << '\n';
	std::cout << sum(1,2,3,4,5) << '\n';
}
\end{lstlisting}

折叠方式有四种:

\begin{table}[H]
\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{折叠方式}    & \textbf{语法} & \textbf{展开方式}                  \\ \hline
		一元右折叠 & (pack op ...)   & (arg1 op (... op (argN-1 op argN))) \\ \hline
		一元左折叠  & (... op pack)   & (((arg1 op arg2) op ...) op argN)   \\ \hline
		二元右折叠 &
		\begin{tabular}[c]{@{}l@{}}(pack op ... op\\ init)\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}(arg1 op (... op (argN-1 op (argN\\ op init))))\end{tabular} \\ \hline
		二元左折叠 &
		\begin{tabular}[c]{@{}l@{}}(init op ... op\\ pack)\end{tabular} &
		\begin{tabular}[c]{@{}l@{}}((((init op arg1) op arg2) op ...)\\ op argN)\end{tabular} \\ \hline
	\end{tabular}
\end{table}

\begin{center}
表 3.1
\end{center}

在该表中，使用了以下名词:

\begin{itemize}
\item
pack是一个包含未展开形参包的表达式，arg1、arg2、argN-1和argN是这个包中包含的参数。

\item
op下面是一个二元操作符 : +, -, *, /, \%, \^, \&, |, =, <, >, <{}<, >{}>, +=, -=, *=, /=, \%=, \^=, \&=, |=, <{}<=, >{}>=, ==, !=, <=, >=, \&\&, ||, ,(逗号表达式), .*, ->*.

\item
init不包含未展开参数包的表达式。
\end{itemize}

In a unary fold, if the pack does not contain any elements, only some operators are allowed. These are listed in the following table, along with the value of the empty pack:

\begin{table}[H]
\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Operator}  & \textbf{Value of the empty pack} \\ \hline
		\&\& (logical AND) & true                             \\ \hline
		|| (logical OR)    & false                            \\ \hline
		, (comma operator) & void()                           \\ \hline
	\end{tabular}
\end{table}

\begin{center}
Table 3.2
\end{center}

Unary and binary folds differ in the use of an initialization value, that is present only for binary folds. Binary folds have the binary operator repeated twice (it must be the same operator). We can transform the variadic function template sum from using a unary right fold expression into one using a binary right fold by including an initialization value. Here is an example:

\begin{lstlisting}[style=styleCXX]
template <typename... T>
int sum_from_zero(T... args)
{
	return (0 + ... + args);
}
\end{lstlisting}

One could say there is no difference between the sum and sum\_from\_zero function templates. That is not actually true. Let's consider the following invocations:

\begin{lstlisting}[style=styleCXX]
int s1 = sum(); // error
int s2 = sum_from_zero(); // OK
\end{lstlisting}

Calling sum without arguments will produce a compiler error, because unary fold expressions (over the operator + in this case) must have non-empty expansions. However, binary fold expressions do not have this problem, so calling sum\_from\_zero without arguments works and the function will return 0.

In these two examples with sum and sum\_from\_zero, the parameter pack args appears directly within the fold expression. However, it can be part of an expression, as long as it is not expanded. This is shown in the following example:

\begin{lstlisting}[style=styleCXX]
template <typename... T>
void printl(T... args)
{
	(..., (std::cout << args)) << '\n';
}

template <typename... T>
void printr(T... args)
{
	((std::cout << args), ...) << '\n';
}
\end{lstlisting}

Here, the parameter pack args is part of the (std::cout << args) expression. This is not a fold expression. A fold expression is ((std::cout << args), ...). This is a unary left fold over the comma operator. The printl and printr functions can be used as in the following snippet:

\begin{lstlisting}[style=styleCXX]
printl('d', 'o', 'g'); // dog
printr('d', 'o', 'g'); // dog
\end{lstlisting}

In both these cases, the text printed to the console is dog. This is because the unary left fold expands to (((std::cout << 'd'), std::cout << 'o'), << std::cout << 'g') and the unary right fold expands to (std::cout << 'd', (std::cout << 'o', (std::cout << 'g'))) and these two are evaluated in the same way. This is because a pair of expressions separated by a comma is evaluated left to right. This is true for the built-in comma operator. For types that overload the comma operator, the behavior depends on how the operator is overloaded. However, there are very few corner cases for overloading the comma operator (such as simplifying indexing multi-dimensional arrays). Libraries such as Boost.Assign and SOCI overload the comma operator, but, in general, this is an operator you should avoid overloading.

Let's consider another example for using the parameter pack in an expression inside a fold expression. The following variadic function template inserts multiple values to the end of a std::vector:

\begin{lstlisting}[style=styleCXX]
template<typename T, typename... Args>
void push_back_many(std::vector<T>& v, Args&&... args)
{
	(v.push_back(args), ...);
}

push_back_many(v, 1, 2, 3, 4, 5); // v = {1, 2, 3, 4, 5}
\end{lstlisting}

The parameter pack args is used with the v.push\_back(args) expression that is folded over the comma operator. The unary left fold expression is (v.push\_back(args), ...).

Fold expressions have several benefits over the use of recursion to implement variadic templates. These benefits are as follows:

\begin{itemize}
\item
Less and simpler code to write.

\item
Fewer template instantiations, which leads to faster compile times.

\item
Potentially faster code since multiple function calls are replaced with a single expression. However, this point may not be true in practice, at least not when optimizations are enabled. We have already seen that the compilers optimize code by removing these function calls.
\end{itemize}

Now that we have seen how to create variadic function templates, variadic class templates, and how to use fold expressions, we are left to discuss the other kinds of templates that can be variadic: alias templates and variable templates. We will start with the former.




















