Variadic function templates are template functions with a variable number of arguments. They borrow the use of the ellipsis (...) for specifying a pack of arguments, which can have different syntax depending on its nature.

To understand the fundamentals for variadic function templates, let's start with an example that rewrites the previous min function:

\begin{lstlisting}[style=styleCXX]
template <typename T>
T min(T a, T b)
{
	return a < b ? a : b;
}

template <typename T, typename... Args>
T min(T a, Args... args)
{
	return min(a, min(args...));
}

int main()
{
	std::cout << "min(42.0, 7.5)=" << min(42.0, 7.5)
	          << '\n';
	std::cout << "min(1,5,3,-4,9)=" << min(1, 5, 3, -4, 9)
	          << '\n';
}
\end{lstlisting}

What we have here are two overloads for the min function. The first is a function template with two parameters that returns the smallest of the two arguments. The second is a function template with a variable number of arguments that recursively calls itself with an expansion of the parameters pack. Although variadic function template implementations look like using some sort of compile-time recursion mechanism (in this case the overload with two parameters acting as the end case), in fact, they're only relying on overloaded functions, instantiated from the template and the set of provided arguments.

The ellipsis (...) is used in three different places, with different meanings, in the implementation of a variadic function template, as can be seen in our example:

\begin{itemize}
\item
To specify a pack of parameters in the template parameters list, as in typename...Args. This is called a template parameter pack. Template parameter packs can be defined for type templates, non-type templates, and template template parameters.

\item
To specify a pack of parameters in the function parameters list, as in Args...
args. This is called a function parameter pack.

\item
To expand a pack in the body of a function, as in args…, seen in the call min(args…). This is called a parameter pack expansion. The result of such an expansion is a comma-separated list of zero or more values (or expressions). This topic will be covered in more detail in the next section.
\end{itemize}

From the call min(1, 5, 3, -4, 9), the compiler is instantiating a set of overloaded functions with 5, 4, 3, and 2 arguments. Conceptually, it is the same as having the following set of overloaded functions:

\begin{lstlisting}[style=styleCXX]
int min(int a, int b)
{
	return a < b ? a : b;
}

int min(int a, int b, int c)
{
	return min(a, min(b, c));
}

int min(int a, int b, int c, int d)
{
	return min(a, min(b, min(c, d)));
}

int min(int a, int b, int c, int d, int e)
{
	return min(a, min(b, min(c, min(d, e))));
}
\end{lstlisting}

As a result, min(1, 5, 3, -4, 9) expands to min(1, min(5, min(3, min(-4, 9)))). This can raise questions about the performance of variadic templates. In practice, however, the compilers perform a lot of optimizations, such as inlining as much as possible. The result is that, in practice, when optimizations are enabled, there will be no actual function calls. You can use online resources, such as Compiler Explorer (\url{https:// godbolt.org/}), to see the code generated by different compilers with different options (such as optimization settings). For instance, let's consider the following snippet (where min is the variadic function template with the implementation shown earlier):

\begin{lstlisting}[style=styleCXX]
int main()
{
	std::cout << min(1, 5, 3, -4, 9);
}
\end{lstlisting}

Compiling this with GCC 11.2 with the -O flag for optimizations produces the following assembly code:

\begin{lstlisting}[style=styleCXX]
sub rsp, 8
mov esi, -4
mov edi, OFFSET FLAT:_ZSt4cout
call std::basic_ostream<char, std::char_traits<char>>
        ::operator<<(int)
mov eax, 0
add rsp, 8
ret
\end{lstlisting}

You don't need to be an expert in assembly to understand what's happening here. The evaluation of the call to min(1, 5, 3, -4, 9) is done at compile-time and the result, -4, is loaded directly into the ESI register. There are no runtime calls, in this particular case, or computation, since everything is known at compile-time. Of course, that is not necessarily always the case.

The following snippet shows an invocation on the min function template that cannot be evaluated at compile-time because its arguments are only known at runtime:

\begin{lstlisting}[style=styleCXX]
int main()
{
	int a, b, c, d, e;
	std::cin >> a >> b >> c >> d >> e;
	std::cout << min(a, b, c, d, e);
}
\end{lstlisting}

This time, the assembly code generated is the following (only showing here the code for the call to the min function):

\begin{lstlisting}[style=styleCXX]
mov esi, DWORD PTR [rsp+12]
mov eax, DWORD PTR [rsp+16]
cmp esi, eax
cmovg esi, eax
mov eax, DWORD PTR [rsp+20]
cmp esi, eax
cmovg esi, eax
mov eax, DWORD PTR [rsp+24]
cmp esi, eax
cmovg esi, eax
mov eax, DWORD PTR [rsp+28]
cmp esi, eax
cmovg esi, eax
mov edi, OFFSET FLAT:_ZSt4cout
call std::basic_ostream<char, std::char_traits<char>>
        ::operator<<(int)
\end{lstlisting}

We can see from this listing that the compiler has inlined all the calls to the min overloads. There is only a series of instructions for loading values into registers, comparisons of register values, and jumps based on the comparison result, but there are no function calls.

When optimizations are disabled, function calls do occur. We can trace these calls that occur during the invocation of the min function by using compiler-specific macros. GCC and Clang provide a macro called \_\_PRETTY\_FUNCTION\_\_ that contains the signature of a function and its name. Similarly, Visual C++ provides a macro, called \_\_FUNCSIG\_\_, that does the same. These could be used within the body of a function to print its name and signature. We can use them as follows:


\begin{lstlisting}[style=styleCXX]
template <typename T>
T min(T a, T b)
{
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
	std::cout << __PRETTY_FUNCTION__ << "\n";
#elif defined(_MSC_VER)
	std::cout << __FUNCSIG__ << "\n";
#endif
	return a < b ? a : b;
}

template <typename T, typename... Args>
T min(T a, Args... args)
{
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
	std::cout << __PRETTY_FUNCTION__ << "\n";
#elif defined(_MSC_VER)
	std::cout << __FUNCSIG__ << "\n";
#endif
	return min(a, min(args...));
}

int main()
{
	min(1, 5, 3, -4, 9);
}
\end{lstlisting}

The result of the execution of this program, when compiled with Clang, is the following:

\begin{lstlisting}[style=styleCXX]
T min(T, Args...) [T = int, Args = <int, int, int, int>]
T min(T, Args...) [T = int, Args = <int, int, int>]
T min(T, Args...) [T = int, Args = <int, int>]
T min(T, T) [T = int]
T min(T, T) [T = int]
T min(T, T) [T = int]
T min(T, T) [T = int]
\end{lstlisting}

On the other hand, when compiled with Visual C++, the output is the following:

\begin{lstlisting}[style=styleCXX]
int __cdecl min<int,int,int,int,int>(int,int,int,int,int)
int __cdecl min<int,int,int,int>(int,int,int,int)
int __cdecl min<int,int,int>(int,int,int)
int __cdecl min<int>(int,int)
int __cdecl min<int>(int,int)
int __cdecl min<int>(int,int)
int __cdecl min<int>(int,int)
\end{lstlisting}

Although the way the signature is formatted is significantly different between Clang/GCC on one hand and VC++ on the other hand, they all show the same: first, an overloaded function with five parameters is called, then one with four parameters, then one with three, and, in the end, there are four calls to the overload with two parameters (which marks the end of the expansion).

Understanding the expansion of parameter packs is key to understanding variadic templates. Therefore, we'll explore this topic in detail in the next section.



