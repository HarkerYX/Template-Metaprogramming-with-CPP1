
As mentioned before, templates are only blueprints from which the compiler creates actual code when it encounters their use. The act of creating a definition for a function, a class, or a variable from the template declaration is called template instantiation. This can be either explicit, when you tell the compiler when it should generate a definition, or implicit, when the compiler generates a new definition as needed. We will look at these two forms in detail in the next sections.

\subsubsubsection{2.5.1\hspace{0.2cm}Implicit instantiation}

Implicit instantiation occurs when the compiler generates definitions based on the use of templates and when no explicit instantiation is present. Implicitly instantiated templates are defined in the same namespace as the template. However, the way compilers create definitions from templates may differ. This is something we will see in the following example. Let's consider this code:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct foo
{
	void f() {}
};

int main()
{
	foo<int> x;
}
\end{lstlisting}

Here, we have a class template called foo with a member function f. In main, we define a variable of the type foo<int> but do not use any of its members. Because it encounters this use of foo, the compiler implicitly defines a specialization of foo for the int type. If you use cppinsights.io, which runs in Clang, you will see the following code:

\begin{lstlisting}[style=styleCXX]
template<>
struct foo<int>
{
	inline void f();
};
\end{lstlisting}

Because the function f is not invoked in our code, it is only declared but not defined. Should we add a call f in main, the specialization would change as follows:

\begin{lstlisting}[style=styleCXX]
template<>
struct foo<int>
{
	inline void f() { }
};
\end{lstlisting}

However, if we add one more function, g, with the following implementation that contains an error, we will get different behaviors with different compilers:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct foo
{
	void f() {}
	void g() {int a = "42";}
};

int main()
{
	foo<int> x;
	x.f();
}
\end{lstlisting}

The body of g contains an error (you could also use a static\_assert(false) statement as an alternative). This code compiles without any problem with VC++, but fails with Clang and GCC. This is because VC++ ignores the parts of the template that are not used, provided that the code is syntactically correct, but the others perform semantic validation before proceeding with template instantiation.


For function templates, implicit instantiation occurs when the user code refers to a function in a context that requires its definition to exist. For class templates, implicit instantiation occurs when the user code refers to a template in a context when a complete type is required or when the completeness of the type affects the code. The typical example of such a context is when an object of such a type is constructed. However, this is not the case when declaring pointers to a class template. To understand how this works, let's consider the following example:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct foo
{
	void f() {}
	void g() {}
};

int main()
{
	foo<int>* p;
	foo<int> x;
	foo<double>* q;
}
\end{lstlisting}

In this snippet, we use the same foo class template from the previous examples, and we declare several variables: p which is a pointer to foo<int>, x which is a foo<int>, and q which is a pointer to foo<double>. The compiler is required to instantiate only foo<int> at this point because of the declaration of x. Now, let's consider some invocations of the member functions f and g as follows:

\begin{lstlisting}[style=styleCXX]
int main()
{
	foo<int>* p;
	foo<int> x;
	foo<double>* q;
	x.f();
	q->g();
}
\end{lstlisting}

With these changes, the compiler is required to instantiate the following:

\begin{itemize}
\item 
foo<int> when the x variable is declared

\item 
foo<int>::f() when the x.f() call occurs

\item 
foo<double> and foo<double>::g() when the q->g() call occurs.
\end{itemize}

On the other hand, the compiler is not required to instantiate foo<int> when the p pointer is declared nor foo<double> when the q pointer is declared. However, the compiler does need to implicitly instantiate a class template specialization when it is involved in pointer conversion. This is shown in the following example:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct control
{};

template <typename T>
struct button : public control<T>
{};

void show(button<int>* ptr)
{
	control<int>* c = ptr;
}
\end{lstlisting}

In the function show, a conversion between button<int>* and control<int>* takes place. Therefore, at this point, the compiler must instantiate button<int>.

When a class template contains static members, those members are not implicitly instantiated when the compiler implicitly instantiates the class template but only when the compiler needs their definition. On the other hand, every specialization of a class template has its own copy of static members as exemplified in the following snippet:

\begin{lstlisting}[style=styleCXX]
template <typename T>
struct foo
{
	static T data;
};

template <typename T> T foo<T>::data = 0;

int main()
{
	foo<int> a;
	foo<double> b;
	foo<double> c;
	
	std::cout << a.data << '\n'; // 0
	std::cout << b.data << '\n'; // 0
	std::cout << c.data << '\n'; // 0
	
	b.data = 42;
	std::cout << a.data << '\n'; // 0
	std::cout << b.data << '\n'; // 42
	std::cout << c.data << '\n'; // 42
}
\end{lstlisting}

The class template foo has a static member variable called data that is initialized after the definition of foo. In the main function, we declare the variable a as an object of foo<int> and b and c as objects of foo<double>. Initially, all of them have the member field data initialized with 0. However, the variables b and c share the same copy of data. Therefore, after the assignment b.data = 42, a.data is still 0, but both b.data and c.data are 42.

Having learned how implicit instantiation works, it is time to move forward and understand the other form of template instantiation, which is explicit instantiation.

\subsubsubsection{2.5.2\hspace{0.2cm}Explicit instantiation}

As a user, you can explicitly tell the compiler to instantiate a class template or a function template. This is called explicit instantiation and it has two forms: explicit instantiation definition and explicit instantiation declaration. We will discuss them in this order.


\hspace*{\fill} \\ %插入空行
\noindent\textbf{Explicit instantiation definition}

An explicit instantiation definition may appear anywhere in a program but after the definition of the template it refers to. The syntax for explicit template instantiation definitions takes the following forms:

\begin{itemize}
\item 
The syntax for class templates is as follows:
\begin{lstlisting}[style=styleCXX]
template class-key template-name <argument-list>
\end{lstlisting}

\item 
The syntax for function templates is as follows:
\begin{lstlisting}[style=styleCXX]
template return-type name<argument-list>(parameter-list);
template return-type name(parameter-list);
\end{lstlisting}
\end{itemize}

As you can see, in all cases, the explicit instantiation definition is introduced with the template keyword but not followed by any parameter list. For class templates, the class-key can be any of the class, struct, or union keywords. For both class and function templates, an explicit instantiation definition with a given argument list can only appear once in the entire program.

We will look at some examples to understand how this works. Here is the first example:

\begin{lstlisting}[style=styleCXX]
namespace ns
{
	template <typename T>
	struct wrapper
	{
		T value;
	};
	template struct wrapper<int>; // [1]
}

template struct ns::wrapper<double>; // [2]

int main() {}
\end{lstlisting}

In this snippet, wrapper<T> is a class template defined in the ns namespace. The statements marked with [1] and [2] in the code are both representing an explicit instantiation definition, for wrapper<int> and wrapper<double> respectively. An explicit instantiation definition can only appear in the same namespace as the template it refers to (as in [1]) to or it must be fully qualified (as in [2]). We can write similar explicit template definitions for a function template:

\begin{lstlisting}[style=styleCXX]
namespace ns
{
	template <typename T>
	T add(T const a, T const b)
	{
		return a + b;
	}

	template int add(int, int); // [1]
}

template double ns::add(double, double); // [2]

int main() { }
\end{lstlisting}

This second example has a striking resemblance to the first. Both [1] and [2] represent explicit template definitions for add<int>() and add<double>().

If the explicit instantiation definition is not in the same namespace as the template, the name must be fully qualified. The use of a using statement does not make the name visible in the current namespace. This is shown in the following example:

\begin{lstlisting}[style=styleCXX]
namespace ns
{
	template <typename T>
	struct wrapper { T value; };
}

using namespace ns;

template struct wrapper<double>; // error
\end{lstlisting}

The last line in this example generates a compile error because wrapper is an unknown name and must be qualified with the namespace name, as in ns::wrapper.

When class members are used for return types or parameter types, member access specification is ignored in explicit instantiation definitions. An example is shown in the following snippet:

\begin{lstlisting}[style=styleCXX]
template <typename T>
class foo
{
	struct bar {};
	
	T f(bar const arg)
	{
		return {};
	}
};

template int foo<int>::f(foo<int>::bar);
\end{lstlisting}

Both the class X<T>::bar and the function foo<T>::f() are private to the foo<T> class, but they can be used in the explicit instantiation definition shown on the last line.

Having seen what explicit instantiation definition is and how it works, the question that arises is when is it useful. Why would you tell the compiler to generate instantiation from a template? The answer is that it helps distribute libraries, reduce build times, and executable sizes. If you are building a library that you want to distribute as a .lib file and that library uses templates, the template definitions that are not instantiated are not put into the library. But that leads to increased build times of your user code every time you use the library. By forcing instantiations of templates in the library, those definitions are put into the object files and the .lib file you are distributing. As a result, your user code only needs to be linked to those available functions in the library file. This is what the Microsoft MSVC CRT libraries do for all the stream, locale, and string classes. The libstdc++ library does the same for string classes and others.

A problem that can arise with template instantiations is that you can end up with multiple definitions, one per translation unit. If the same header that contains a template is included in multiple translation units (.cpp files) and the same template instantiation is used (let's say wrapper<int> from our previous examples), then identical copies of these instantiations are put in each translation unit. This leads to increased object sizes. The problem can be solved with the help of explicit instantiation declarations, which we will look at next.

\hspace*{\fill} \\ %插入空行
\noindent\textbf{Explicit instantiation declaration}

An explicit instantiation declaration (available with C++11) is the way you can tell the compiler that the definition of a template instantiation is found in a different translation unit and that a new definition should not be generated. The syntax is the same as for explicit instantiation definitions except that the keyword extern is used in front of the declaration:

\begin{itemize}
\item 
The syntax for class templates is as follows:
\begin{lstlisting}[style=styleCXX]
extern template class-key template-name <argument-list>
\end{lstlisting}

\item 
The syntax for function templates is as follows:
\begin{lstlisting}[style=styleCXX]
extern template return-type name<argumentlist>(parameter-list);
extern template return-type name(parameter-list);
\end{lstlisting}
\end{itemize}

If you provide an explicit instantiation declaration but no instantiation definition exists in any translation unit of the program, then the result is a compiler warning and a linker error. The technique is to declare an explicit template instantiation in one source file and explicit template declarations in the remaining ones. This will reduce both compilation times and object file sizes.

Let's look at the following example:

\begin{lstlisting}[style=styleCXX]
// wrapper.h
template <typename T>
struct wrapper
{
	T data;
};
extern template wrapper<int>; // [1]

// source1.cpp
#include "wrapper.h"
#include <iostream>
template wrapper<int>; // [2]

void f()
{
	ext::wrapper<int> a{ 42 };
	std::cout << a.data << '\n';
}

// source2.cpp
#include "wrapper.h"
#include <iostream>

void g()
{
	wrapper<int> a{ 100 };
	std::cout << a.data << '\n';
}

// main.cpp
#include "wrapper.h"

int main()
{
	wrapper<int> a{ 0 };
}
\end{lstlisting}

In this example, we can see the following:

\begin{itemize}
\item 
The wrapper.h header contains a class template called wrapper<T>. On the line marked with [1] there is an explicit instantiation declaration for wrapper<int> that tells the compiler not to generate definitions for this instantiation when a source file (translation unit) including this header is compiled.

\item 
The source1.cpp file includes wrapper.h and on the line marked with [2] contains an explicit instantiation definition for wrapper<int>. This is the only definition for this instantiation within the entire program.

\item 
The source files source2.cpp and main.cpp are both using wrapper<int> but without any explicit instantiation definition or declaration. That is because the explicit declaration from wrapper.h is visible when the header is included in each of these files.
\end{itemize}

Alternatively, the explicit instantiation declaration could be taken away from the header file but then it must be added to each source file that includes the header and that is likely to be forgotten.

When you do explicit template declarations, keep in mind that a class member function that is defined within the body of the class is always considered inline and therefore it will always be instantiated. Therefore, you can only use the extern keyword for member functions that are defined outside of the class body.

Now that we have looked at what template instantiation is, we will continue with another important topic, template specialization, which is the term used for the definition created from a template instantiation to handle a specific set of template arguments.















